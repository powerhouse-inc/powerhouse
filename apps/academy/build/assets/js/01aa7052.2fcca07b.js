"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[828],{1014:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>u});const o=JSON.parse('{"id":"academy/TodoListTutorial/AddTestsForTodoListActions","title":"Step 3 \u2014 Adding our own tests for the document model actions","description":"Similarly to the operation handler logic, when you add a new module to your document model, we generate some boilerplate tests for your code.","source":"@site/docs/academy/10-TodoListTutorial/03-AddTestsForTodoListActions.md","sourceDirName":"academy/10-TodoListTutorial","slug":"/academy/TodoListTutorial/AddTestsForTodoListActions","permalink":"/academy/TodoListTutorial/AddTestsForTodoListActions","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/10-TodoListTutorial/03-AddTestsForTodoListActions.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{}}');var d=n(5723),i=n(7474);const c={},a="Step 3 \u2014 Adding our own tests for the document model actions",s={},u=[{value:"Tests for update operations",id:"tests-for-update-operations",level:2},{value:"Test updating the todo item text",id:"test-updating-the-todo-item-text",level:3},{value:"Check your work",id:"check-your-work",level:4},{value:"Test updating the todo item checked state",id:"test-updating-the-todo-item-checked-state",level:3},{value:"Check your work",id:"check-your-work-1",level:4},{value:"Test for deleting todo items",id:"test-for-deleting-todo-items",level:2},{value:"Check your work",id:"check-your-work-2",level:4},{value:"Final result",id:"final-result",level:2},{value:"Check your work",id:"check-your-work-3",level:2},{value:"Up next: generating an editor for our <code>TodoList</code> documents",id:"up-next-generating-an-editor-for-our-todolist-documents",level:3}];function r(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.header,{children:(0,d.jsx)(t.h1,{id:"step-3--adding-our-own-tests-for-the-document-model-actions",children:"Step 3 \u2014 Adding our own tests for the document model actions"})}),"\n",(0,d.jsx)(t.p,{children:"Similarly to the operation handler logic, when you add a new module to your document model, we generate some boilerplate tests for your code."}),"\n",(0,d.jsxs)(t.p,{children:["Take a look in ",(0,d.jsx)(t.code,{children:"document-models/todo-list/src/tests/todos.test.ts"})]}),"\n",(0,d.jsx)(t.p,{children:'You will see that we have some basic "sanity check" style tests for you already. These make sure that your operations are at least able to result in a valid document model state. You should copy these boilerplate checks in your other tests to ensure that your outputs are valid.'}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-ts",children:'/**\n * This is a scaffold file meant for customization:\n * - change it by adding new tests or modifying the existing ones\n */\n\nimport { describe, it, expect } from "vitest";\nimport { generateMock } from "@powerhousedao/codegen";\nimport {\n  reducer,\n  utils,\n  isTodoListDocument,\n  addTodoItem,\n  AddTodoItemInputSchema,\n  updateTodoItem,\n  UpdateTodoItemInputSchema,\n  deleteTodoItem,\n  DeleteTodoItemInputSchema,\n} from "todo-tutorial/document-models/todo-list";\n\ndescribe("Todos Operations", () => {\n  it("should handle addTodoItem operation", () => {\n    // the `createDocument` utility function from your document model creates\n    // an a new empty document, i.e. one with your default initial state\n    const document = utils.createDocument();\n\n    // the generate mock function takes one of your generated input schemas\n    // and creates an object populated with random values for each field\n    const input = generateMock(AddTodoItemInputSchema());\n\n    // we call your document model\'s reducer with the new document we just created\n    // and the action we want to test, `addTodoItem` in this case\n    // the reducer returns a new object, which is the document with the action applied\n    // if successful, there will be an operation which corresponds to this action\n    // in the updated document\'s operations list\n    const updatedDocument = reducer(document, addTodoItem(input));\n\n    // when you generate a document model, we give you some validation utilities like\n    // `isTodoListDocument` which confirms the document is of the correct form in a way\n    // that typescript recognizes\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n    // at the start a document will have 0 operations, so after applying this action\n    // there should now be one operation\n    expect(updatedDocument.operations.global).toHaveLength(1);\n\n    // the operation added to the list should correspond to the correct action type\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      "ADD_TODO_ITEM",\n    );\n\n    // the operation added should have used the correct input\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n\n    // the index of the operation should be 0, since it is the first and only operation\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n  });\n  it("should handle updateTodoItem operation", () => {\n    // ...\n  });\n  it("should handle deleteTodoItem operation", () => {\n    // ...\n  });\n});\n'})}),"\n",(0,d.jsxs)(t.p,{children:["Since testing the ",(0,d.jsx)(t.code,{children:"addTodoItemOperation"})," is such a simple case, we have not added further testing here. You are welcome to add a more test cases for it if you want."]}),"\n",(0,d.jsx)(t.h2,{id:"tests-for-update-operations",children:"Tests for update operations"}),"\n",(0,d.jsx)(t.h3,{id:"test-updating-the-todo-item-text",children:"Test updating the todo item text"}),"\n",(0,d.jsxs)(t.p,{children:["Let's add some more sophisticated tests for our ",(0,d.jsx)(t.code,{children:"updateTodoItem"})," operation. We want to know that we can update todos successfully, and that we we do so it only changes the values we want to change, while leaving the rest as is."]}),"\n",(0,d.jsx)(t.p,{children:'Delete the existing "should handle updateTodoItem operation" test.'}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-diff",children:'- it("should handle updateTodoItem operation", () => {\n-   const document = utils.createDocument();\n-   const input = generateMock(UpdateTodoItemInputSchema());\n-   const updatedDocument = reducer(document, updateTodoItem(input));\n-   expect(isTodoListDocument(updatedDocument)).toBe(true);\n-   expect(updatedDocument.operations.global).toHaveLength(1);\n-   expect(updatedDocument.operations.global[0].action.type).toBe(\n-     "UPDATE_TODO_ITEM",\n-   );\n-   expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n-     input,\n-   );\n-   expect(updatedDocument.operations.global[0].index).toEqual(0);\n- });\n'})}),"\n",(0,d.jsx)(t.p,{children:"Let's test that the text of a todo item is updated correctly first. Put this code in the place where you just deleted the existing test case:"}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-ts",children:'  it("should handle updateTodoItem operation to update text", () => {\n    // we need there to already be a todo item in the document, \n    // since we want to test updating an existing document\n    const mockItem = generateMock(TodoItemSchema());\n\n    // we also need to generate a mock input for the update operation we are testing\n    const input: UpdateTodoItemInput = generateMock(\n      UpdateTodoItemInputSchema(),\n    );\n\n    // since the mocks are generated with random values, we need to set the `id` on our mock input \n    // to match the `id` of the existing mock input\n    input.id = mockItem.id;\n\n    // we want to easily check if the item\'s text was updated to be our new value, \n    // so we assign a variable and use that for the mock input\'s text field\n    const newText = "new text";\n    input.text = newText;\n\n    // we are only testing updating the text here, so we want the checked field on the input\n    // to be undefined, i.e. it should not change anything on the existing item\n    input.checked = undefined;\n\n    // we can pass a different initial state to the `createDocument` utility,\n    // so in this case we pass in an `items` array with our existing item already in it\n    const document = utils.createDocument({\n      global: {\n        items: [mockItem],\n      },\n    });\n\n    /* The following checks are copied from the boilerplate */\n\n    // create an updated document by applying the reducer with the action and input\n    const updatedDocument = reducer(document, updateTodoItem(input));\n\n    // use our validator to check that the document conforms to the document model schema\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n    // there should now be one operation in the operations list\n    expect(updatedDocument.operations.global).toHaveLength(1);\n\n    // the operation applied should correspond to an action of the correct type\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      "UPDATE_TODO_ITEM",\n    );\n\n    // the operation applied should have used the correct input\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n\n    // the operation applied should be the first operation in the list\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n\n    /* The following checks are unique to this test case */\n\n    // find the updated item in the items list by its `id`\n    const updatedItem = updatedDocument.state.global.items.find(\n      (item) => item.id === input.id,\n    );\n\n    // the item\'s text should now be updated to be our new text\n    expect(updatedItem?.text).toBe(newText);\n\n    // the item\'s `checked` field should be unchanged.\n    expect(updatedItem?.checked).toBe(mockItem.checked);\n  });\n'})}),"\n",(0,d.jsx)(t.h4,{id:"check-your-work",children:"Check your work"}),"\n",(0,d.jsxs)(t.p,{children:["Running ",(0,d.jsx)(t.code,{children:"pnpm tsc && pnpm lint && pnpm test"})," should pass"]}),"\n",(0,d.jsx)(t.h3,{id:"test-updating-the-todo-item-checked-state",children:"Test updating the todo item checked state"}),"\n",(0,d.jsxs)(t.p,{children:["Now let's do the same thing, but for the checked state of an item. This test is essentially just the same as the above, but we update the ",(0,d.jsx)(t.code,{children:"checked"})," field while leaving the ",(0,d.jsx)(t.code,{children:"text"})," field ",(0,d.jsx)(t.code,{children:"undefined"}),"."]}),"\n",(0,d.jsx)(t.p,{children:"Add this code below the test case we just added:"}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-ts",children:"  it(\"should handle updateTodoItem operation to update checked\", () => {\n    // generate a mock existing item\n    const mockItem = generateMock(TodoItemSchema());\n\n    // generate a mock input\n    const input: UpdateTodoItemInput = generateMock(\n      UpdateTodoItemInputSchema(),\n    );\n\n    // set the mock input's `id` to the mock item's `id`\n    input.id = mockItem.id;\n    \n    // we want the new `checked` field value to be the opposite of the randomly generated value from the mock\n    const newChecked = !mockItem.checked;\n    input.checked = newChecked;\n\n    // leave the `text` field unchanged\n    input.text = undefined;\n\n    // create a document with the existing item in it\n    const document = utils.createDocument({\n      global: {\n        items: [mockItem],\n      },\n    });\n\n    // apply the reducer with the action and the mock input\n    const updatedDocument = reducer(document, updateTodoItem(input));\n\n    /* The following checks are copied from the boilerplate */\n\n    // validate your document\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n   // check your operations\n    expect(updatedDocument.operations.global).toHaveLength(1);\n\n    // check the operation's action type\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      \"UPDATE_TODO_ITEM\",\n    );\n\n    // check the operation's input\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n\n    // check the operation's index\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n\n    /* The following checks are unique to this test case */\n\n    // get the updated item by it's `id`\n    const updatedItem = updatedDocument.state.global.items.find(\n      (item) => item.id === input.id,\n    );\n\n    // the item's `text` field should remain unchanged\n    expect(updatedItem?.text).toBe(mockItem.text);\n\n    // the item's `checked` field should be updated to our new checked value\n    expect(updatedItem?.checked).toBe(newChecked);\n  });\n"})}),"\n",(0,d.jsx)(t.h4,{id:"check-your-work-1",children:"Check your work"}),"\n",(0,d.jsxs)(t.p,{children:["Running ",(0,d.jsx)(t.code,{children:"pnpm tsc && pnpm lint && pnpm test"})," should pass"]}),"\n",(0,d.jsx)(t.h2,{id:"test-for-deleting-todo-items",children:"Test for deleting todo items"}),"\n",(0,d.jsxs)(t.p,{children:["You will have seen that the tests for the ",(0,d.jsx)(t.code,{children:"deleteTodoItem"})," operation passed, even though we didn't set up an existing item to delete. This is because the boilerplate just checks that the operation was applied with the correct inputs, which it technically was. Checking that it actually had the ",(0,d.jsx)(t.em,{children:"result"})," we want is our job."]}),"\n",(0,d.jsxs)(t.p,{children:["Update the ",(0,d.jsx)(t.code,{children:"deleteTodoItem"})," operation test case to also create an existing item and then check that is was actually deleted:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-diff",children:'  it("should handle deleteTodoItem operation", () => {\n-   const document = utils.createDocument();\n-   const input = generateMock(DeleteTodoItemInputSchema());\n+   const mockItem = generateMock(TodoItemSchema());\n+   const document = utils.createDocument({\n+     global: {\n+       items: [mockItem],\n+     },\n+   });\n+   const input: DeleteTodoItemInput = generateMock(\n+     DeleteTodoItemInputSchema(),\n+   );\n+   input.id = mockItem.id;\n    const updatedDocument = reducer(document, deleteTodoItem(input));\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n    expect(updatedDocument.operations.global).toHaveLength(1);\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      "DELETE_TODO_ITEM",\n    );\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n+   const updatedItems = updatedDocument.state.global.items;\n+   expect(updatedItems).toHaveLength(0);\n  });\n'})}),"\n",(0,d.jsx)(t.h4,{id:"check-your-work-2",children:"Check your work"}),"\n",(0,d.jsxs)(t.p,{children:["Running ",(0,d.jsx)(t.code,{children:"pnpm tsc && pnpm lint && pnpm test"})," should pass"]}),"\n",(0,d.jsx)(t.h2,{id:"final-result",children:"Final result"}),"\n",(0,d.jsxs)(t.p,{children:["After these updates, your ",(0,d.jsx)(t.code,{children:"document-models/todo-list/src/tests/todos.test.ts"})," file should look like this:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-ts",children:'/**\n * This is a scaffold file meant for customization:\n * - change it by adding new tests or modifying the existing ones\n */\n\nimport { describe, it, expect } from "vitest";\nimport { generateMock } from "@powerhousedao/codegen";\nimport type {\n  AddTodoItemInput,\n  DeleteTodoItemInput,\n  UpdateTodoItemInput,\n} from "todo-tutorial/document-models/todo-list";\nimport {\n  reducer,\n  utils,\n  isTodoListDocument,\n  addTodoItem,\n  AddTodoItemInputSchema,\n  updateTodoItem,\n  UpdateTodoItemInputSchema,\n  deleteTodoItem,\n  DeleteTodoItemInputSchema,\n  TodoItemSchema,\n} from "todo-tutorial/document-models/todo-list";\n\ndescribe("Todos Operations", () => {\n  it("should handle addTodoItem operation", () => {\n    const document = utils.createDocument();\n    const input: AddTodoItemInput = generateMock(AddTodoItemInputSchema());\n\n    const updatedDocument = reducer(document, addTodoItem(input));\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n    expect(updatedDocument.operations.global).toHaveLength(1);\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      "ADD_TODO_ITEM",\n    );\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n  });\n  it("should handle updateTodoItem operation to update text", () => {\n    const mockItem = generateMock(TodoItemSchema());\n    const input: UpdateTodoItemInput = generateMock(\n      UpdateTodoItemInputSchema(),\n    );\n    input.id = mockItem.id;\n    const newText = "new text";\n    input.text = newText;\n    input.checked = undefined;\n    const document = utils.createDocument({\n      global: {\n        items: [mockItem],\n      },\n    });\n\n    const updatedDocument = reducer(document, updateTodoItem(input));\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n    expect(updatedDocument.operations.global).toHaveLength(1);\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      "UPDATE_TODO_ITEM",\n    );\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n    const updatedItem = updatedDocument.state.global.items.find(\n      (item) => item.id === input.id,\n    );\n    expect(updatedItem?.text).toBe(newText);\n    expect(updatedItem?.checked).toBe(mockItem.checked);\n  });\n  it("should handle updateTodoItem operation to update checked", () => {\n    const mockItem = generateMock(TodoItemSchema());\n    const input: UpdateTodoItemInput = generateMock(\n      UpdateTodoItemInputSchema(),\n    );\n    input.id = mockItem.id;\n    const newChecked = !mockItem.checked;\n    input.checked = newChecked;\n    input.text = undefined;\n    const document = utils.createDocument({\n      global: {\n        items: [mockItem],\n      },\n    });\n\n    const updatedDocument = reducer(document, updateTodoItem(input));\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n    expect(updatedDocument.operations.global).toHaveLength(1);\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      "UPDATE_TODO_ITEM",\n    );\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n    const updatedItem = updatedDocument.state.global.items.find(\n      (item) => item.id === input.id,\n    );\n    expect(updatedItem?.text).toBe(mockItem.text);\n    expect(updatedItem?.checked).toBe(newChecked);\n  });\n  it("should handle deleteTodoItem operation", () => {\n    const mockItem = generateMock(TodoItemSchema());\n    const document = utils.createDocument({\n      global: {\n        items: [mockItem],\n      },\n    });\n    const input: DeleteTodoItemInput = generateMock(\n      DeleteTodoItemInputSchema(),\n    );\n    input.id = mockItem.id;\n    const updatedDocument = reducer(document, deleteTodoItem(input));\n    expect(isTodoListDocument(updatedDocument)).toBe(true);\n\n    expect(updatedDocument.operations.global).toHaveLength(1);\n    expect(updatedDocument.operations.global[0].action.type).toBe(\n      "DELETE_TODO_ITEM",\n    );\n    expect(updatedDocument.operations.global[0].action.input).toStrictEqual(\n      input,\n    );\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n    const updatedItems = updatedDocument.state.global.items;\n    expect(updatedItems).toHaveLength(0);\n  });\n});\n'})}),"\n",(0,d.jsx)(t.h2,{id:"check-your-work-3",children:"Check your work"}),"\n",(0,d.jsx)(t.p,{children:"To make sure all works as expected, we should:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["check types\nrun: ",(0,d.jsx)(t.code,{children:"pnpm tsc"})]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["check linting\nrun: ",(0,d.jsx)(t.code,{children:"pnpm lint"})]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["check tests\nrun: ",(0,d.jsx)(t.code,{children:"pnpm test"})]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["make sure your code matches the code in the completed step branch\nrun: ",(0,d.jsx)(t.code,{children:"git diff your-branch-name step-3-complete-implemented-tests-for-todo-operations"})]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(t.h3,{id:"up-next-generating-an-editor-for-our-todolist-documents",children:["Up next: generating an editor for our ",(0,d.jsx)(t.code,{children:"TodoList"})," documents"]}),"\n",(0,d.jsxs)(t.p,{children:["Up next, we'll generate a boilerplate document editor for our ",(0,d.jsx)(t.code,{children:"TodoList"})," documents."]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(r,{...e})}):r(e)}},7474:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>a});var o=n(2155);const d={},i=o.createContext(d);function c(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:c(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);