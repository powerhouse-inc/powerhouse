"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[1893],{5818:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"academy/TodoListTutorial/ImplementTodoListDocumentModelReducerOperationHandlers","title":"Step 2 \u2014 Implement the TodoList document model reducer operation handlers","description":"Adding the logic for handling operations with reducers","source":"@site/docs/academy/10-TodoListTutorial/02-ImplementTodoListDocumentModelReducerOperationHandlers.md","sourceDirName":"academy/10-TodoListTutorial","slug":"/academy/TodoListTutorial/ImplementTodoListDocumentModelReducerOperationHandlers","permalink":"/academy/TodoListTutorial/ImplementTodoListDocumentModelReducerOperationHandlers","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/10-TodoListTutorial/02-ImplementTodoListDocumentModelReducerOperationHandlers.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{}}');var d=o(5723),i=o(7474);const r={},a="Step 2 \u2014 Implement the TodoList document model reducer operation handlers",s={},c=[{value:"Adding the logic for handling operations with reducers",id:"adding-the-logic-for-handling-operations-with-reducers",level:2},{value:"What we have so far",id:"what-we-have-so-far",level:2},{value:"Check your work",id:"check-your-work",level:2},{value:"Up next: tests for our new operation handlers",id:"up-next-tests-for-our-new-operation-handlers",level:3}];function l(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(t.header,{children:(0,d.jsxs)(t.h1,{id:"step-2--implement-the-todolist-document-model-reducer-operation-handlers",children:["Step 2 \u2014 Implement the ",(0,d.jsx)(t.code,{children:"TodoList"})," document model reducer operation handlers"]})}),"\n",(0,d.jsx)(t.h2,{id:"adding-the-logic-for-handling-operations-with-reducers",children:"Adding the logic for handling operations with reducers"}),"\n",(0,d.jsx)(t.p,{children:"Your document model update's the state of a given document by applying a set of append-only actions. Once these have been applied to the document, we call them operations."}),"\n",(0,d.jsx)(t.p,{children:"The document model does this with a reducer \u2014 a function which takes the existing state and a given action, and then returns the new state with the action applied."}),"\n",(0,d.jsx)(t.h2,{id:"what-we-have-so-far",children:"What we have so far"}),"\n",(0,d.jsxs)(t.p,{children:["The operation handler logic for each module is found in ",(0,d.jsx)(t.code,{children:"document-models/SOME-DOCUMENT-MODEL/src/reducers/SOME-MODULE-NAME.ts"}),"."]}),"\n",(0,d.jsxs)(t.p,{children:["So for our todos module, we will implement our handler logic in ",(0,d.jsx)(t.code,{children:"document-models/todo-list/src/reducers/todos.ts"})]}),"\n",(0,d.jsx)(t.p,{children:'When you generated your document model code, we created a boilerplate implementation of the reducer logic for each of the operations we defined in step 1. You will see that there are functions for handling each of the operations, but all they do is throw "not implemented" errors.'}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-ts",children:'import type { TodoListTodosOperations } from "todo-tutorial/document-models/todo-list";\n\nexport const todoListTodosOperations: TodoListTodosOperations = {\n  addTodoItemOperation(state, action) {\n    // TODO: Implement "addTodoItemOperation" reducer\n    throw new Error(\'Reducer "addTodoItemOperation" not yet implemented\');\n  },\n  updateTodoItemOperation(state, action) {\n    // TODO: Implement "updateTodoItemOperation" reducer\n    throw new Error(\'Reducer "updateTodoItemOperation" not yet implemented\');\n  },\n  deleteTodoItemOperation(state, action) {\n    // TODO: Implement "deleteTodoItemOperation" reducer\n    throw new Error(\'Reducer "deleteTodoItemOperation" not yet implemented\');\n  },\n};\n'})}),"\n",(0,d.jsx)(t.p,{children:"Let's add the handler logic for each operation in the same order we defined them in the previous step."}),"\n",(0,d.jsxs)(t.p,{children:["To handle the ",(0,d.jsx)(t.code,{children:"addTodoItemOperation"}),", all we need to do is create an ",(0,d.jsx)(t.code,{children:"id"})," for our new operation, and then push an object with that ",(0,d.jsx)(t.code,{children:"id"})," and the rest of the action input into the ",(0,d.jsx)(t.code,{children:"items"})," array in our state."]}),"\n",(0,d.jsxs)(t.p,{children:["Update your ",(0,d.jsx)(t.code,{children:"addTodoItemOperation"})," like so:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-diff",children:'import type { TodoListTodosOperations } from "todo-tutorial/document-models/todo-list";\n\nexport const todoListTodosOperations: TodoListTodosOperations = {\n-  addTodoItemOperation(state, action) {\n-    // TODO: Implement "addTodoItemOperation" reducer\n-    throw new Error(\'Reducer "addTodoItemOperation" not yet implemented\');\n-  },\n+ addTodoItemOperation(state, action) {\n+    const id = generateId();\n+    state.items.push({ ...action.input, id, checked: false });\n+  },\n  updateTodoItemOperation(state, action) {\n    // TODO: Implement "updateTodoItemOperation" reducer\n    throw new Error(\'Reducer "updateTodoItemOperation" not yet implemented\');\n  },\n  deleteTodoItemOperation(state, action) {\n    // TODO: Implement "deleteTodoItemOperation" reducer\n    throw new Error(\'Reducer "deleteTodoItemOperation" not yet implemented\');\n  },\n};\n'})}),"\n",(0,d.jsxs)(t.p,{children:["Under the hood, we use a library for making the functions always create and return new copies of the state, i.e. they are always ",(0,d.jsx)(t.em,{children:"immutable"}),". This is why you don't actually have to return your new state, the newly created copy of the state is used automatically."]}),"\n",(0,d.jsxs)(t.p,{children:["The ",(0,d.jsx)(t.code,{children:"updateTodoOperation"})," works in much the same way, except this time instead of creating a new ",(0,d.jsx)(t.code,{children:"id"}),", we find the item in the items array which has the given id. Then we spread out the rest of the values we get from the action input, same as when creating."]}),"\n",(0,d.jsxs)(t.p,{children:["Update your ",(0,d.jsx)(t.code,{children:"updateTodoOperation"})," to be like so:"]}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-diff",children:'export const todoListTodosOperations: TodoListTodosOperations = {\n    addTodoItemOperation(state, action) {\n        // TODO: Implement "addTodoItemOperation" reducer\n        throw new Error(\'Reducer "addTodoItemOperation" not yet implemented\');\n    },\n    updateTodoItemOperation(state, action) {\n        // TODO: Implement "updateTodoItemOperation" reducer\n        throw new Error(\'Reducer "updateTodoItemOperation" not yet implemented\');\n    },\n    deleteTodoItemOperation(state, action) {\n        // TODO: Implement "deleteTodoItemOperation" reducer\n        throw new Error(\'Reducer "deleteTodoItemOperation" not yet implemented\');\n    }\n};\n'})}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-diff",children:'export const todoListTodosOperations: TodoListTodosOperations = {\n    addTodoItemOperation(state, action) {\n      const id = generateId();\n      state.items.push({ ...action.input, id, checked: false });\n    },\n-   updateTodoItemOperation(state, action) {\n-       // TODO: Implement "updateTodoItemOperation" reducer\n-       throw new Error(\'Reducer "updateTodoItemOperation" not yet implemented\');\n-   },\n+    updateTodoItemOperation(state, action) {\n+      const item = state.items.find((item) => item.id === action.input.id);\n+      if (!item) return;\n+      item.text = action.input.text ?? item.text;\n+      item.checked = action.input.checked ?? item.checked;\n+    },\n    deleteTodoItemOperation(state, action) {\n        // TODO: Implement "deleteTodoItemOperation" reducer\n        throw new Error(\'Reducer "deleteTodoItemOperation" not yet implemented\');\n    }\n};\n'})}),"\n",(0,d.jsx)(t.p,{children:"The delete operation is the simplest of the three. All we need to do is filter the items array so that it no longer contains the item with the given id."}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-diff",children:"export const todoListTodosOperations: TodoListTodosOperations = {\n  addTodoItemOperation(state, action) {\n    const id = generateId();\n    state.items.push({ ...action.input, id, checked: false });\n  },\n  updateTodoItemOperation(state, action) {\n    const item = state.items.find((item) => item.id === action.input.id);\n    if (!item) return;\n    item.text = action.input.text ?? item.text;\n    item.checked = action.input.checked ?? item.checked;\n  },\n- deleteTodoItemOperation(state, action) {\n-   state.items = state.items.filter((item) => item.id !== action.input.id);\n- },\n+ deleteTodoItemOperation(state, action) {\n+   state.items = state.items.filter((item) => item.id !== action.input.id);\n+ },\n};\n"})}),"\n",(0,d.jsx)(t.p,{children:"With that all done, your final result should look like this:"}),"\n",(0,d.jsx)(t.pre,{children:(0,d.jsx)(t.code,{className:"language-ts",children:'import { generateId } from "document-model/core";\nimport type { TodoListTodosOperations } from "todo-tutorial/document-models/todo-list";\n\nexport const todoListTodosOperations: TodoListTodosOperations = {\n  addTodoItemOperation(state, action) {\n    const id = generateId();\n    state.items.push({ ...action.input, id, checked: false });\n  },\n  updateTodoItemOperation(state, action) {\n    const item = state.items.find((item) => item.id === action.input.id);\n    if (!item) return;\n    item.text = action.input.text ?? item.text;\n    item.checked = action.input.checked ?? item.checked;\n  },\n  deleteTodoItemOperation(state, action) {\n    state.items = state.items.filter((item) => item.id !== action.input.id);\n  },\n};\n'})}),"\n",(0,d.jsx)(t.h2,{id:"check-your-work",children:"Check your work"}),"\n",(0,d.jsx)(t.p,{children:"To make sure all works as expected, we should:"}),"\n",(0,d.jsxs)(t.ul,{children:["\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["check types\nrun: ",(0,d.jsx)(t.code,{children:"pnpm tsc"})]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["check linting\nrun: ",(0,d.jsx)(t.code,{children:"pnpm lint"})]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["check tests\nrun: ",(0,d.jsx)(t.code,{children:"pnpm test"})]}),"\n"]}),"\n",(0,d.jsxs)(t.li,{children:["\n",(0,d.jsxs)(t.p,{children:["make sure your code matches the code in the completed step branch\nrun: ",(0,d.jsx)(t.code,{children:"git diff your-branch-name step-2-complete-implemented-todo-list-document-model-reducer-operation-handlers"})]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(t.h3,{id:"up-next-tests-for-our-new-operation-handlers",children:"Up next: tests for our new operation handlers"}),"\n",(0,d.jsx)(t.p,{children:"Up next, you'll implement some custom tests to check the behavior of our new code."})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}},7474:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var n=o(2155);const d={},i=n.createContext(d);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);