"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[5046],{7474:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(2155);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}},7533:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"academy/MasteryTrack/DocumentModelCreation/ImplementDocumentModelTests","title":"Implement document model tests","description":"Ensuring robustness and reliability","source":"@site/docs/academy/02-MasteryTrack/02-DocumentModelCreation/06-ImplementDocumentModelTests.md","sourceDirName":"academy/02-MasteryTrack/02-DocumentModelCreation","slug":"/academy/MasteryTrack/DocumentModelCreation/ImplementDocumentModelTests","permalink":"/academy/MasteryTrack/DocumentModelCreation/ImplementDocumentModelTests","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/02-DocumentModelCreation/06-ImplementDocumentModelTests.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Implement document reducers","permalink":"/academy/MasteryTrack/DocumentModelCreation/ImplementDocumentReducers"},"next":{"title":"Example: Todo-demo-package","permalink":"/academy/MasteryTrack/DocumentModelCreation/ExampleToDoListRepository"}}');var s=n(5723),r=n(7474);const i={},a="Implement document model tests",d={},c=[{value:"Ensuring robustness and reliability",id:"ensuring-robustness-and-reliability",level:2},{value:"Practical implementation: Writing and running the To-do List tests",id:"practical-implementation-writing-and-running-the-to-do-list-tests",level:2},{value:"1. Implement the reducer tests",id:"1-implement-the-reducer-tests",level:3},{value:"2. Run the tests",id:"2-run-the-tests",level:3},{value:"Best practices for document model tests",id:"best-practices-for-document-model-tests",level:2},{value:"Conclusion: The payoff of diligent testing",id:"conclusion-the-payoff-of-diligent-testing",level:2},{value:"Up next",id:"up-next",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"implement-document-model-tests",children:"Implement document model tests"})}),"\n",(0,s.jsx)(t.h2,{id:"ensuring-robustness-and-reliability",children:"Ensuring robustness and reliability"}),"\n",(0,s.jsxs)(t.p,{children:["In the previous chapter, we implemented the core reducer logic for our document model. Now, we reach a critical stage that underpins the reliability and correctness of our entire model: ",(0,s.jsx)(t.strong,{children:"Implementing Document Model Tests"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Testing is not an afterthought; it's an integral part of the development lifecycle, especially in systems like Powerhouse where data integrity and predictable state transitions are paramount. Well-crafted tests serve as a safety net, allowing you to refactor and extend your document model with confidence."}),"\n",(0,s.jsxs)(t.p,{children:["This document provides a practical, hands-on tutorial for testing the ",(0,s.jsx)(t.code,{children:"To-do List"})," document model reducers you have just built."]}),"\n",(0,s.jsx)(t.h2,{id:"practical-implementation-writing-and-running-the-to-do-list-tests",children:"Practical implementation: Writing and running the To-do List tests"}),"\n",(0,s.jsxs)(t.p,{children:["This tutorial assumes you have implemented the ",(0,s.jsx)(t.code,{children:"To-do List"})," reducers as described in the previous chapter and that the code generator has created a test file skeleton at ",(0,s.jsx)(t.code,{children:"document-models/to-do-list/src/reducers/tests/to-do-list.test.ts"}),"."]}),"\n",(0,s.jsxs)(n,{children:[(0,s.jsxs)("summary",{children:["Tutorial: Implementing and running the ",(0,s.jsx)(t.code,{children:"To-do List"})," reducer tests"]}),(0,s.jsx)(t.h3,{id:"1-implement-the-reducer-tests",children:"1. Implement the reducer tests"}),(0,s.jsxs)(t.p,{children:["With the reducer logic in place, it's critical to test it. Navigate to the generated test file at ",(0,s.jsx)(t.code,{children:"document-models/to-do-list/src/reducers/tests/to-do-list.test.ts"})," and replace its contents with the following test suite."]}),(0,s.jsxs)(t.p,{children:["This suite tests each operation, verifying not only that the ",(0,s.jsx)(t.code,{children:"items"})," array is correct, but also that our ",(0,s.jsx)(t.code,{children:"stats"})," object is updated as expected and that the operation itself is recorded properly in the document's history."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'import utils from "../../gen/utils.js";\nimport { reducer } from "../../gen/reducer.js";\nimport * as creators from "../../gen/creators.js";\nimport { ToDoListDocument } from "../../gen/types.js";\n\ndescribe("Todolist Operations", () => {\n  let document: ToDoListDocument;\n\n  beforeEach(() => {\n    // REMARKS: We start with a fresh, empty document for each test.\n    // The `createDocument` utility initializes the state with an empty \'items\' array\n    // and a \'stats\' object with all counts set to 0.\n    document = utils.createDocument();\n  });\n\n  it("should handle addTodoItem operation", () => {\n    const input = { id: "1", text: "Buy milk" };\n\n    // REMARKS: We apply the \'addTodoItem\' operation.\n    const updatedDocument = reducer(document, creators.addTodoItem(input));\n\n    // REMARKS: We verify the operation was recorded in the document\'s history.\n    // Powerhouse records every operation in an array.\n    expect(updatedDocument.operations.global).toHaveLength(1);\n    expect(updatedDocument.operations.global[0].type).toBe("ADD_TODO_ITEM");\n    // REMARKS: We also check that the input data and index are recorded correctly.\n    expect(updatedDocument.operations.global[0].input).toStrictEqual(input);\n    expect(updatedDocument.operations.global[0].index).toEqual(0);\n\n    // REMARKS: Finally, we verify the state was updated according to our reducer logic.\n    expect(updatedDocument.state.global.items).toHaveLength(1);\n    expect(updatedDocument.state.global.stats.total).toBe(1);\n    expect(updatedDocument.state.global.stats.unchecked).toBe(1);\n  });\n\n  it("should handle updateTodoItem operation", () => {\n    // REMARKS: For an update, we first need to add an item.\n    const addInput = { id: "1", text: "Buy milk" };\n    const updateInput = { id: "1", checked: true }; // We\'ll test checking the item.\n\n    // REMARKS: Operations are applied sequentially to build up document state.\n    const createdDocument = reducer(document, creators.addTodoItem(addInput));\n    const updatedDocument = reducer(\n      createdDocument,\n      creators.updateTodoItem(updateInput),\n    );\n\n    // REMARKS: Now we should have 2 operations in the history.\n    expect(updatedDocument.operations.global).toHaveLength(2);\n    expect(updatedDocument.operations.global[1].type).toBe("UPDATE_TODO_ITEM");\n    expect(updatedDocument.operations.global[1].input).toStrictEqual(\n      updateInput,\n    );\n\n    // REMARKS: We check that the state reflects the update, including our stats.\n    expect(updatedDocument.state.global.items[0].checked).toBe(true);\n    expect(updatedDocument.state.global.stats.total).toBe(1);\n    expect(updatedDocument.state.global.stats.unchecked).toBe(0);\n    expect(updatedDocument.state.global.stats.checked).toBe(1);\n  });\n\n  it("should handle deleteTodoItem operation", () => {\n    const addInput = { id: "1", text: "Buy milk" };\n    const deleteInput = { id: "1" };\n\n    const createdDocument = reducer(document, creators.addTodoItem(addInput));\n    const updatedDocument = reducer(\n      createdDocument,\n      creators.deleteTodoItem(deleteInput),\n    );\n\n    // REMARKS: After deletion, we still have 2 operations in history,\n    // but the items array is now empty and the stats are back to zero.\n    expect(updatedDocument.operations.global).toHaveLength(2);\n    expect(updatedDocument.operations.global[1].type).toBe("DELETE_TODO_ITEM");\n    expect(updatedDocument.state.global.items).toHaveLength(0);\n    expect(updatedDocument.state.global.stats.total).toBe(0);\n    expect(updatedDocument.state.global.stats.unchecked).toBe(0);\n  });\n});\n'})}),(0,s.jsx)(t.h3,{id:"2-run-the-tests",children:"2. Run the tests"}),(0,s.jsx)(t.p,{children:"Now, run the tests from your project's root directory to verify your implementation."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"pnpm run test\n"})}),(0,s.jsx)(t.p,{children:"Or with npm:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"npm test\n"})}),(0,s.jsxs)(t.p,{children:["If all tests pass, you have successfully verified the core logic of your ",(0,s.jsx)(t.code,{children:"To-do List"})," document model. This ensures that the reducers you wrote behave exactly as expected."]})]}),"\n",(0,s.jsx)(t.h2,{id:"best-practices-for-document-model-tests",children:"Best practices for document model tests"}),"\n",(0,s.jsx)(t.p,{children:"While the tutorial provides a concrete example, keep these general best practices in mind when writing your tests:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Isolate Tests"}),": Each ",(0,s.jsx)(t.code,{children:"it"})," block should ideally test one specific aspect or scenario. ",(0,s.jsx)(t.code,{children:"beforeEach"})," is crucial for resetting state between tests."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Descriptive Names"}),": Name your ",(0,s.jsx)(t.code,{children:"describe"})," and ",(0,s.jsx)(t.code,{children:"it"})," blocks clearly so they explain what's being tested."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"AAA Pattern (Arrange, Act, Assert)"}),":","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Arrange"}),": Set up the initial state and any required test data (e.g., using ",(0,s.jsx)(t.code,{children:"utils.createDocument()"})," and defining ",(0,s.jsx)(t.code,{children:"input"})," objects)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Act"}),": Execute the operation by calling the ",(0,s.jsx)(t.code,{children:"reducer"})," with an action from a ",(0,s.jsx)(t.code,{children:"creator"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Assert"}),": Check if the outcome is as expected using ",(0,s.jsx)(t.code,{children:"expect()"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Test Immutability"}),": A key assertion is to ensure the state is not mutated directly. You can check that a new array or object was created: ",(0,s.jsx)(t.code,{children:"expect(newState.items).not.toBe(oldState.items);"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Cover Edge Cases"}),": Test what happens when an operation receives invalid input (e.g., trying to update an item that doesn't exist). Your test should confirm the reducer either throws an error or returns the state unchanged, depending on your implementation."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Run Tests Frequently"}),": Integrate testing into your development workflow. Run tests after making changes to ensure you haven't broken anything. The ",(0,s.jsx)(t.code,{children:"pnpm run test"})," (or ",(0,s.jsx)(t.code,{children:"npm test"}),") command is your friend."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"conclusion-the-payoff-of-diligent-testing",children:"Conclusion: The payoff of diligent testing"}),"\n",(0,s.jsx)(t.p,{children:"Implementing comprehensive tests for your document model reducers is an investment that pays dividends in the long run. It leads to:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Higher Quality Models"}),": More reliable and robust document models with fewer bugs."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Increased Confidence"}),": Ability to make changes and refactor code without fear of breaking existing functionality."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Easier Debugging"}),": When tests fail, they pinpoint the exact operation and scenario that's problematic."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Better Collaboration"}),": Tests clarify the intended behavior of the document model for all team members."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'By following the tutorial and applying these best practices, you can build a strong suite of tests that safeguard the integrity and functionality of your document models. This diligence is a hallmark of a "Mastery Track" developer, ensuring that the solutions you build are not just functional but also stable, maintainable, and trustworthy.'}),"\n",(0,s.jsx)(t.h2,{id:"up-next",children:"Up next"}),"\n",(0,s.jsxs)(t.p,{children:["In the next chapter of the Mastery Track - Building User Experiences you will learn how to implement an ",(0,s.jsx)(t.a,{href:"/academy/MasteryTrack/BuildingUserExperiences/BuildingDocumentEditors",children:"editor"})," for your document model so you can see a simple user interface for the ",(0,s.jsx)(t.strong,{children:"To-do List"})," document model in action."]}),"\n",(0,s.jsxs)(t.p,{children:["For a complete, working example, you can always have a look at the ",(0,s.jsx)(t.a,{href:"/academy/MasteryTrack/DocumentModelCreation/ExampleToDoListRepository",children:"Example To-do List Repository"})," which contains the full implementation of the concepts discussed in this Mastery Track."]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);