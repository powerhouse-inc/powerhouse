"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[2244],{7022:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"academy/MasteryTrack/DocumentModelCreation/SpecifyDocumentOperations","title":"Specify document operations","description":"In the previous section, we defined the state schema for our document model. Now, we turn our attention to a critical aspect of document model creation: specifying document operations. These operations are the heart of your document\'s behavior, dictating how its state can be modified.","source":"@site/docs/academy/02-MasteryTrack/02-DocumentModelCreation/03-SpecifyDocumentOperations.md","sourceDirName":"academy/02-MasteryTrack/02-DocumentModelCreation","slug":"/academy/MasteryTrack/DocumentModelCreation/SpecifyDocumentOperations","permalink":"/academy/MasteryTrack/DocumentModelCreation/SpecifyDocumentOperations","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/02-DocumentModelCreation/03-SpecifyDocumentOperations.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Specify the state schema","permalink":"/academy/MasteryTrack/DocumentModelCreation/SpecifyTheStateSchema"},"next":{"title":"Use the document model generator","permalink":"/academy/MasteryTrack/DocumentModelCreation/UseTheDocumentModelGenerator"}}');var o=t(5723),s=t(7474);const r={},d="Specify document operations",a={},c=[{value:"What are document operations?",id:"what-are-document-operations",level:2},{value:"Connecting operations to the schema",id:"connecting-operations-to-the-schema",level:2},{value:"Designing effective document operations",id:"designing-effective-document-operations",level:2},{value:"1. Granularity",id:"1-granularity",level:3},{value:"2. Naming conventions",id:"2-naming-conventions",level:3},{value:"3. Input types (payloads)",id:"3-input-types-payloads",level:3},{value:"4. Immutability and pure functions",id:"4-immutability-and-pure-functions",level:3},{value:"Role in event sourcing and CQRS",id:"role-in-event-sourcing-and-cqrs",level:2},{value:"From specification to implementation",id:"from-specification-to-implementation",level:2},{value:"Practical implementation: Defining operations in Connect",id:"practical-implementation-defining-operations-in-connect",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"specify-document-operations",children:"Specify document operations"})}),"\n",(0,o.jsxs)(n.p,{children:["In the previous section, we defined the state schema for our document model. Now, we turn our attention to a critical aspect of document model creation: ",(0,o.jsx)(n.strong,{children:"specifying document operations"}),". These operations are the heart of your document's behavior, dictating how its state can be modified."]}),"\n",(0,o.jsx)(n.h2,{id:"what-are-document-operations",children:"What are document operations?"}),"\n",(0,o.jsx)(n.p,{children:"In Powerhouse, document models adhere to event sourcing principles. This means that every change to a document's state is the result of a sequence of operations (or events). Instead of directly mutating the state, you define specific, named operations that describe the intended change."}),"\n",(0,o.jsxs)(n.p,{children:["For example, in our ",(0,o.jsx)(n.code,{children:"To-do List"})," document model, operations might include:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"}),": To add a new task."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"}),": To modify an existing task (e.g., change its text or mark it as completed)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"DELETE_TODO_ITEM"}),": To remove a task."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Each operation acts as a command that, when applied, transitions the document from one state to the next. The complete history of these operations defines the document's journey to its current state."}),"\n",(0,o.jsx)(n.h2,{id:"connecting-operations-to-the-schema",children:"Connecting operations to the schema"}),"\n",(0,o.jsxs)(n.p,{children:['In the "Define To-do List Document Model" chapter in the "Get Started" guide, we used GraphQL ',(0,o.jsx)(n.code,{children:"input"})," types to define the structure of the data required for each operation. Let's revisit that:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"# Defines a GraphQL input type for adding a new to-do item\ninput AddTodoItemInput {\n  id: ID!\n  text: String!\n}\n\n# Defines a GraphQL input type for updating a to-do item\ninput UpdateTodoItemInput {\n  id: ID!\n  text: String\n  checked: Boolean\n}\n\n# Defines a GraphQL input type for deleting a to-do item\ninput DeleteTodoItemInput {\n  id: ID!\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["These ",(0,o.jsx)(n.code,{children:"input"})," types are not just abstract definitions; they are the ",(0,o.jsx)(n.strong,{children:"specifications for our document operations"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"AddTodoItemInput"})})," specifies that to execute an ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"})," operation, we need an ",(0,o.jsx)(n.code,{children:"id"})," and ",(0,o.jsx)(n.code,{children:"text"})," for the new item."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"UpdateTodoItemInput"})})," specifies that for an ",(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"})," operation, we need the ",(0,o.jsx)(n.code,{children:"id"})," of the item to update, and optionally new ",(0,o.jsx)(n.code,{children:"text"})," or a ",(0,o.jsx)(n.code,{children:"checked"})," status."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"DeleteTodoItemInput"})})," specifies that a ",(0,o.jsx)(n.code,{children:"DELETE_TODO_ITEM"})," operation requires the ",(0,o.jsx)(n.code,{children:"id"})," of the item to be removed."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The Powerhouse Connect application uses these GraphQL input types when you define operations within a module (e.g., the ",(0,o.jsx)(n.code,{children:"to_do_list"})," module with operations ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"}),", ",(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"}),", ",(0,o.jsx)(n.code,{children:"DELETE_TODO_ITEM"}),")."]}),"\n",(0,o.jsx)(n.h2,{id:"designing-effective-document-operations",children:"Designing effective document operations"}),"\n",(0,o.jsx)(n.p,{children:"Careful design of your document operations is crucial for a robust and maintainable document model. Here are some key considerations:"}),"\n",(0,o.jsx)(n.h3,{id:"1-granularity",children:"1. Granularity"}),"\n",(0,o.jsx)(n.p,{children:"Operations should be granular enough to represent distinct user intentions or logical changes."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Too coarse:"})," An operation like ",(0,o.jsx)(n.code,{children:"MODIFY_TODOLIST"})," that takes a whole new list of items would be too broad. It would be hard to track specific changes and could lead to complex reducer logic."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Too fine:"})," While possible, having separate operations like ",(0,o.jsx)(n.code,{children:"SET_TODO_ITEM_TEXT"})," and ",(0,o.jsx)(n.code,{children:"SET_TODO_ITEM_CHECKED_STATUS"})," might be overly verbose if these are often updated together. ",(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"})," with optional fields offers a good balance."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Just right:"})," The ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"}),", ",(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"}),", and ",(0,o.jsx)(n.code,{children:"DELETE_TODO_ITEM"})," operations for our ",(0,o.jsx)(n.code,{children:"ToDoList"})," are good examples. They represent clear, atomic changes."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"2-naming-conventions",children:"2. Naming conventions"}),"\n",(0,o.jsxs)(n.p,{children:["Clear and consistent naming makes your operations understandable. A common convention is ",(0,o.jsx)(n.code,{children:"VERB_NOUN"})," or ",(0,o.jsx)(n.code,{children:"VERB_NOUN_SUBJECT"}),"."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Examples: ",(0,o.jsx)(n.code,{children:"ADD_ITEM"}),", ",(0,o.jsx)(n.code,{children:"UPDATE_USER_PROFILE"}),", ",(0,o.jsx)(n.code,{children:"ASSIGN_TASK_TO_USER"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["In our case: ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"}),", ",(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"}),", ",(0,o.jsx)(n.code,{children:"DELETE_TODO_ITEM"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The name you provide in the Connect UI (e.g., ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"}),") directly corresponds to the operation type that will be recorded and that your reducers will handle."]}),"\n",(0,o.jsx)(n.h3,{id:"3-input-types-payloads",children:"3. Input types (payloads)"}),"\n",(0,o.jsx)(n.p,{children:"The input type for an operation (its payload) should contain all the necessary information to perform that operation, and nothing more."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Completeness:"})," If an operation needs a user ID to authorize a change, include it in the input."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Conciseness:"})," Avoid including data that isn't directly used by the operation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Clarity:"})," Use descriptive field names within your input types. ",(0,o.jsx)(n.code,{children:"action.input.text"})," is clearer than ",(0,o.jsx)(n.code,{children:"action.input.t"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The GraphQL ",(0,o.jsx)(n.code,{children:"input"})," types we defined earlier (",(0,o.jsx)(n.code,{children:"AddTodoItemInput"}),", ",(0,o.jsx)(n.code,{children:"UpdateTodoItemInput"}),", ",(0,o.jsx)(n.code,{children:"DeleteTodoItemInput"}),") serve precisely this purpose. They ensure that whoever triggers an operation provides the correct data in the correct format."]}),"\n",(0,o.jsx)(n.h3,{id:"4-immutability-and-pure-functions",children:"4. Immutability and pure functions"}),"\n",(0,o.jsxs)(n.p,{children:["While not specified in the operation definition itself, remember that the ",(0,o.jsx)(n.em,{children:"implementation"})," of these operations (the reducers) should treat state as immutable and behave as pure functions. The operation specification (input type) provides the data for these pure functions."]}),"\n",(0,o.jsx)(n.h2,{id:"role-in-event-sourcing-and-cqrs",children:"Role in event sourcing and CQRS"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Events:"})," Each successfully executed operation is recorded as an event in the document's history. This history provides an audit trail and allows for replaying events to reconstruct state, which is invaluable for debugging and understanding how a document evolved."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Commands:"}),' Document operations are essentially "commands" in a Command Query Responsibility Segregation (CQRS) pattern. They represent an intent to change the state. The processing of this command (by the reducer) leads to one or more events being stored and the state being updated.']}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"from-specification-to-implementation",children:"From specification to implementation"}),"\n",(0,o.jsx)(n.p,{children:"Specifying your document operations is the bridge between defining your data structure (the state schema) and implementing the logic that changes that data (the reducers)."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"You define the state schema"})," (e.g., ",(0,o.jsx)(n.code,{children:"ToDoListState"}),", ",(0,o.jsx)(n.code,{children:"ToDoItem"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"You specify the operations"})," that can alter this state, along with their required input data (e.g., ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"})," with ",(0,o.jsx)(n.code,{children:"AddTodoItemInput"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Next, you will implement reducers"})," for each specified operation. Each reducer will take the current state and an operation's input, and produce a new state."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The generated code from ",(0,o.jsx)(n.code,{children:"ph generate"})," (as seen in ",(0,o.jsx)(n.code,{children:"03-ImplementOperationReducers.md"}),") will create a structure for your reducers based on the operations you specified in the Connect application (which, in turn, were based on your GraphQL input types)."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, the ",(0,o.jsx)(n.code,{children:"ToDoListToDoListOperations"})," type generated by Powerhouse will expect methods corresponding to ",(0,o.jsx)(n.code,{children:"addTodoItemOperation"}),", ",(0,o.jsx)(n.code,{children:"updateTodoItemOperation"}),", and ",(0,o.jsx)(n.code,{children:"deleteTodoItemOperation"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { ToDoListToDoListOperations } from "../../gen/to-do-list/operations.js";\n\nexport const reducer: ToDoListToDoListOperations = {\n  addTodoItemOperation(state, action, dispatch) {\n    // Implementation uses action.input which matches AddTodoItemInput\n  },\n  updateTodoItemOperation(state, action, dispatch) {\n    // Implementation uses action.input which matches UpdateTodoItemInput\n  },\n  deleteTodoItemOperation(state, action, dispatch) {\n    // Implementation uses action.input which matches DeleteTodoItemInput\n  },\n};\n'})}),"\n",(0,o.jsx)(n.h2,{id:"practical-implementation-defining-operations-in-connect",children:"Practical implementation: Defining operations in Connect"}),"\n",(0,o.jsxs)(n.p,{children:["Now that you understand the theory, let's walk through the practical steps of defining these operations for our ",(0,o.jsx)(n.code,{children:"To-do List"})," document model within the Powerhouse Connect application."]}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Tutorial: Specifying To-do List operations"}),(0,o.jsxs)(n.p,{children:["Assuming you have already defined the state schema for the ",(0,o.jsx)(n.code,{children:"To-do List"})," as covered in the previous section, follow these steps to add the operations:"]}),(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Create a Module for Operations:"}),"\nBelow the schema editor in Connect, find the input field labeled ",(0,o.jsx)(n.code,{children:"Add module"}),". Modules help organize your operations."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Type ",(0,o.jsx)(n.code,{children:"to_do_list"})," into the field and press Enter."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsxs)(n.strong,{children:["Add the ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"})," Operation:"]}),"\nA new field, ",(0,o.jsx)(n.code,{children:"Add operation"}),", will appear under your new module."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Type ",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"})," into this field and press Enter."]}),"\n",(0,o.jsxs)(n.li,{children:["An editor will appear for the operation's input type. You need to define the data required for this operation. Paste the following GraphQL ",(0,o.jsx)(n.code,{children:"input"})," definition into the editor:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"# Defines a GraphQL input type for adding a new to-do item\ninput AddTodoItemInput {\n  id: ID!\n  text: String!\n}\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["Add the ",(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"})," Operation:"]})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["In the ",(0,o.jsx)(n.code,{children:"Add operation"})," field again, type ",(0,o.jsx)(n.code,{children:"UPDATE_TODO_ITEM"})," and press Enter."]}),"\n",(0,o.jsxs)(n.li,{children:["Paste the corresponding ",(0,o.jsx)(n.code,{children:"input"})," definition into its editor:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"# Defines a GraphQL input type for updating a to-do item\ninput UpdateTodoItemInput {\n  id: ID!\n  text: String\n  checked: Boolean\n}\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["Add the ",(0,o.jsx)(n.code,{children:"DELETE_TODO_ITEM"})," Operation:"]})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Finally, type ",(0,o.jsx)(n.code,{children:"DELETE_TODO_ITEM"})," in the ",(0,o.jsx)(n.code,{children:"Add operation"})," field and press Enter."]}),"\n",(0,o.jsxs)(n.li,{children:["Paste its ",(0,o.jsx)(n.code,{children:"input"})," definition:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"# Defines a GraphQL input type for deleting a to-do item\ninput DeleteTodoItemInput {\n  id: ID!\n}\n"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Review and Export:"}),"\nAfter adding all three operations, your document model specification in Connect is complete for now. You can see how each operation (",(0,o.jsx)(n.code,{children:"ADD_TODO_ITEM"}),", etc.) is now explicitly linked to an input type that defines its payload."]}),"\n",(0,o.jsxs)(n.p,{children:["The next step in a real project would be to click the ",(0,o.jsx)(n.code,{children:"Export"})," button to save this specification file. In the next chapter, we will see how this exported file is used to generate code for our reducers."]}),"\n"]}),"\n"]})]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:["Specifying document operations is a foundational step in building robust and predictable document models in Powerhouse. By clearly defining the ",(0,o.jsx)(n.strong,{children:'"what" (the operation and its input)'})," before implementing the ",(0,o.jsx)(n.strong,{children:'"how" (the reducer logic)'}),", you create a clear contract for state transitions. This approach enhances type safety, testability, and the overall maintainability of your document model."]}),"\n",(0,o.jsx)(n.p,{children:"In the next section, we will dive deeper into the implementation of the reducer functions for these specified operations."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},7474:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(2155);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);