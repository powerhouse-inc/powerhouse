"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[2872],{1802:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"academy/MasteryTrack/WorkWithData/GraphQLAtPowerhouse","title":"GraphQL at Powerhouse","description":"In this section, we will cover the core concepts of GraphQL with examples applied to the Powerhouse ecosystem. GraphQL plays a fundamental role in defining document model data schemas, handling data access patterns, and enabling event-driven workflows within the Powerhouse ecosystem.","source":"@site/docs/academy/02-MasteryTrack/04-WorkWithData/01-GraphQLAtPowerhouse.md","sourceDirName":"academy/02-MasteryTrack/04-WorkWithData","slug":"/academy/MasteryTrack/WorkWithData/GraphQLAtPowerhouse","permalink":"/academy/MasteryTrack/WorkWithData/GraphQLAtPowerhouse","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/04-WorkWithData/01-GraphQLAtPowerhouse.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Work with data","permalink":"/category/work-with-data"},"next":{"title":"Using the API","permalink":"/academy/MasteryTrack/WorkWithData/UsingTheAPI"}}');var s=t(5723),i=t(7474);const a={},o="GraphQL at Powerhouse",l={},d=[{value:"Why GraphQL?",id:"why-graphql",level:3},{value:"GraphQL: Core concepts",id:"graphql-core-concepts",level:2},{value:"Schema",id:"schema",level:3},{value:"Fields and arguments",id:"fields-and-arguments",level:3},{value:"Introspection",id:"introspection",level:3},{value:"Connections, edges, and nodes",id:"connections-edges-and-nodes",level:3},{value:"Mutations",id:"mutations",level:3},{value:"GraphQL Subgraphs in Powerhouse",id:"graphql-subgraphs-in-powerhouse",level:2},{value:"Fetching data from the Reactor",id:"fetching-data-from-the-reactor",level:3},{value:"Operational data stores",id:"operational-data-stores",level:3},{value:"CQRS Architecture with GraphQL",id:"cqrs-architecture-with-graphql",level:2},{value:"Read and write separation",id:"read-and-write-separation",level:3},{value:"GraphQL and Event-Driven Architecture",id:"graphql-and-event-driven-architecture",level:2},{value:"How GraphQL fits into EDA",id:"how-graphql-fits-into-eda",level:3},{value:"Example: Powerhouse&#39;s event flow",id:"example-powerhouses-event-flow",level:3},{value:"GraphQL Subscriptions",id:"graphql-subscriptions",level:2},{value:"Summary",id:"summary",level:2}];function h(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"graphql-at-powerhouse",children:"GraphQL at Powerhouse"})}),"\n",(0,s.jsxs)(n.p,{children:["In this section, we will cover ",(0,s.jsx)(n.strong,{children:"the core concepts of GraphQL with examples applied to the Powerhouse ecosystem"}),". GraphQL plays a fundamental role in defining document model data schemas, handling data access patterns, and enabling event-driven workflows within the Powerhouse ecosystem."]}),"\n",(0,s.jsx)(n.p,{children:"More specifically, GraphQL is used as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.strong,{children:"schema definition language (SDL)"})," for defining our document models and thereby self-documenting the API to the data model. It allows developers to define the structure and relationships of data in a strongly-typed format."]}),"\n",(0,s.jsxs)(n.li,{children:["As the ",(0,s.jsx)(n.strong,{children:"query language in subgraphs"}),", which allow different services to expose and query structured data dynamically."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-graphql",children:"Why GraphQL?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Precision"}),": Instead of over-fetching or under-fetching data, GraphQL enables you to specify the precise data requirements in your query."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Endpoint"}),": With GraphQL, you can access all the data you need through one endpoint, reducing the number of network requests."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic Queries"}),": Its introspective nature allows developers to explore the API's schema dynamically, which streamlines development and documentation."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"graphql-core-concepts",children:"GraphQL: Core concepts"}),"\n",(0,s.jsx)(n.h3,{id:"schema",children:"Schema"}),"\n",(0,s.jsx)(n.p,{children:"The schema defines the structure of a GraphQL API. It acts as a contract between the client and server, detailing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Data Types"}),": The various types of data that can be queried.",(0,s.jsx)(n.br,{}),"\n","For example the contributor type and the project type"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Fields"}),": The available fields on each type.",(0,s.jsx)(n.br,{}),"\n","For example the contributor type has a field 'name' and the project type has a field 'title'"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Relationships"}),": How different types relate to each other.",(0,s.jsx)(n.br,{}),"\n","For example the contributor type has a relationship with the project type"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Example of a Powerhouse Contributor schema in GraphQL"',children:"type Contributor {\n  id: ID!\n  name: String!\n  reputationScore: Float\n  projects: [Project] # The Contributor type has a field 'projects' that returns an array of Project objects\n}\n\ntype Project {\n  id: ID!\n  title: String!\n  status: String\n  budget: Float\n}\n\ntype Query {\n  getContributor(id: ID!): Contributor\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"With the following query someone can request the contributor with the id 123"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Example of a query to get a contributor"',children:'query {\n  getContributor(id: "123") {\n    name\n    reputationScore\n    projects {      # Accessing the related projects\n      title\n      status\n    }\n  }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"fields-and-arguments",children:"Fields and arguments"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Field"}),": A specific piece of data you can request from an object. When you build a query, you select the fields you want to retrieve."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Argument"}),": Key-value pairs that can be attached to fields to customize and refine the query. Some fields require arguments to work correctly, especially when dealing with mutations."]}),"\n",(0,s.jsx)(n.p,{children:"Powerhouse uses invoices as part of its decentralized operations. With GraphQL, an invoice query might look like this:\nHere, contributorId and status are arguments that filter the results to return only paid invoices for a specific contributor."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Fetching an Invoice with Filtering"',children:'query {\n  getInvoices(contributorId: "456", status: "PAID") {\n    id\n    amount\n    currency\n    dueDate\n  }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"introspection",children:"Introspection"}),"\n",(0,s.jsx)(n.p,{children:"GraphQL APIs are self-documenting. Through introspection, you can query the API to retrieve details about its schema, including:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The list of ",(0,s.jsx)(n.strong,{children:"available types and fields"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"relationships"})," between those types. This capability is particularly useful for developing dynamic client applications and auto-generating documentation."]}),"\n",(0,s.jsx)(n.p,{children:"Developers might want to see what data structures are available. This makes it easy to explore document models and read models in Powerhouse without needing to consult extensive external documentation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Discovering Available Queries"',children:"{\n  __schema {\n    types {\n      name\n      fields {\n        name\n      }\n    }\n  }\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"connections-edges-and-nodes",children:"Connections, edges, and nodes"}),"\n",(0,s.jsx)(n.p,{children:"When dealing with lists of data, GraphQL employs a pattern that includes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Connection"}),": A structure that represents a list of related objects."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Edge"}),": Represents the link between individual nodes (objects) in a connection. Each edge contains:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A node field (the actual object)."}),"\n",(0,s.jsx)(n.li,{children:"A cursor for pagination."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Node"}),": The individual object in the connection. When querying nodes, you continue selecting subfields until all the data resolves to scalar values."]}),"\n",(0,s.jsx)(n.p,{children:"To efficiently fetch invoices in Powerhouse, a paginated query could look like this.\nThis allows Powerhouse Switchboard to efficiently handle large datasets and return results incrementally"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Paginated List of Invoices"',children:'query {\n  invoices(first: 10, after: "cursor123") {\n    edges {\n      node {\n        id\n        amount\n        dueDate\n      }\n      cursor\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n  }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"mutations",children:"Mutations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["While queries retrieve data, ",(0,s.jsx)(n.strong,{children:"mutations modify data"}),". In Powerhouse, a contributor might need to submit an invoice after completing a task. A GraphQL mutation for this could be:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Submitting an Invoice"',children:'mutation {\n  submitInvoice(\n    input: {\n      contributorId: "123"\n      amount: 500.00\n      currency: "USD"\n      dueDate: "2024-03-01"\n    }\n  ) {\n    id\n    status\n  }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"graphql-subgraphs-in-powerhouse",children:"GraphQL Subgraphs in Powerhouse"}),"\n",(0,s.jsxs)(n.p,{children:["Powerhouse structures its data into ",(0,s.jsx)(n.strong,{children:"subgraphs"}),", which are modular GraphQL services that connect to the Reactor (Powerhouse's core data infrastructure) or Data Stores fueled by data from processors. Each subgraph has its own SDL, ensuring modularity and flexibility while working within the ecosystem."]}),"\n",(0,s.jsx)(n.h3,{id:"fetching-data-from-the-reactor",children:"Fetching data from the Reactor"}),"\n",(0,s.jsxs)(n.p,{children:["Powerhouse uses GraphQL to expose system-level data, such as drives, users, and operational records through the ",(0,s.jsx)(n.strong,{children:"System Subgraph"}),", which allows querying of drives, stored files and folders."]}),"\n",(0,s.jsx)(n.h3,{id:"operational-data-stores",children:"Operational data stores"}),"\n",(0,s.jsx)(n.p,{children:"Custom subgraphs can be created to store and retrieve operational data in real time. For example, a subgraph can track file uploads and expose this data via GraphQL queries:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="File Schema Example"',children:"type File {\n  id: ID!\n  name: String!\n  size: Int!\n  createdAt: DateTime!\n}\n\ntype Query {\n  getFile(id: ID!): File\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This schema ensures that every File entity has an ID, name, size, and timestamp, providing a structured approach to file management data."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"cqrs-architecture-with-graphql",children:"CQRS Architecture with GraphQL"}),"\n",(0,s.jsxs)(n.p,{children:["Powerhouse uses ",(0,s.jsx)(n.strong,{children:"CQRS (Command Query Responsibility Segregation)"})," to separate write operations (commands) from read operations (queries). This improves system scalability and flexibility:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GraphQL Queries"})," handle read operations, retrieving structured data efficiently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GraphQL Mutations"})," handle write operations, modifying the state in a controlled manner"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Powerhouse's subgraphs act as the read layer, while processors handle write operations into operational data stores. This prevents conflicts between querying and modifying data."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Layer"}),(0,s.jsx)(n.th,{children:"Role"}),(0,s.jsx)(n.th,{children:"GraphQL Usage"}),(0,s.jsx)(n.th,{children:"Implementation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Write Model (Commands)"}),(0,s.jsx)(n.td,{children:"Handles state changes (adding, modifying, deleting)"}),(0,s.jsx)(n.td,{children:"GraphQL Mutations"}),(0,s.jsx)(n.td,{children:"Processor"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Read Model (Queries)"}),(0,s.jsx)(n.td,{children:"Optimized for fetching/reading/retrieving data"}),(0,s.jsx)(n.td,{children:"GraphQL Queries"}),(0,s.jsx)(n.td,{children:"Subgraph"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"read-and-write-separation",children:"Read and write separation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Read Model (Query)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Optimized for data retrieval"}),"\n",(0,s.jsx)(n.li,{children:"Structured using GraphQL Queries"}),"\n",(0,s.jsx)(n.li,{children:"Aggregates and exposes data via a subgraph"}),"\n",(0,s.jsx)(n.li,{children:"Pulls data from Operational Data Stores, Analytics Stores, and Reactor"}),"\n",(0,s.jsx)(n.li,{children:"Subgraphs do not directly modify the data\u2014they only expose pre-processed information"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Example Query Operation"',children:'query {\n  getFile(id: "123") {\n    name\n    size\n    createdAt\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Write Model (Mutation)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Handles state changes (adding, modifying, deleting)"}),"\n",(0,s.jsx)(n.li,{children:"Structured using GraphQL Mutations"}),"\n",(0,s.jsx)(n.li,{children:"Writes data to Operational Data Stores"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Example Mutation Operation"',children:'mutation {\n  createFile(name: "document.pdf", size: 1024) {\n    id\n    name\n    createdAt\n  }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"graphql-and-event-driven-architecture",children:"GraphQL and Event-Driven Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Event-Driven Architecture (EDA) enables asynchronous processing where events trigger actions. Powerhouse uses GraphQL to expose real-time event data from its Reactor and Operational Data Stores."}),"\n",(0,s.jsx)(n.h3,{id:"how-graphql-fits-into-eda",children:"How GraphQL fits into EDA"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-Time Data Exposure"})," \u2013 Subgraphs fetch event-based data updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Subscription Mechanism"})," \u2013 Powerhouse is working towards integrating GraphQL Subscriptions for real-time updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient Decoupling"})," \u2013 Events are stored in an operational datastore, and GraphQL queries retrieve structured results"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-powerhouses-event-flow",children:"Example: Powerhouse's event flow"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Processor detects an event (e.g., file upload)"}),"\n",(0,s.jsx)(n.li,{children:"Writes event data to the Operational Data Store"}),"\n",(0,s.jsx)(n.li,{children:"Subgraph exposes the updated data via GraphQL"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"graphql-subscriptions",children:"GraphQL Subscriptions"}),"\n",(0,s.jsxs)(n.p,{children:["Although Powerhouse currently uses queries and mutations, ",(0,s.jsx)(n.strong,{children:"GraphQL Subscriptions"})," could allow real-time streaming of event-based data in future implementations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:'title="Example Future Subscription"',children:"subscription {\n  fileUploaded {\n    id\n    name\n    size\n    createdAt\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This would enable clients to listen for new file uploads without polling, providing a more efficient real-time experience."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"GraphQL offers a streamlined and efficient approach to data retrieval, particularly useful when you need granular control over your API interactions. In the Powerhouse ecosystem, GraphQL serves multiple critical functions:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Schema Definition"}),": Defines document models and self-documents APIs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Subgraph Architecture"}),": Enables modular, scalable data services"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CQRS Implementation"}),": Separates read and write operations for better performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event-Driven Integration"}),": Supports real-time data exposure and future subscription capabilities"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By defining robust schemas, using precise fields and arguments, leveraging introspection, and implementing subgraphs with CQRS principles, GraphQL minimizes unnecessary data transfers while maximizing flexibility and scalability in the Powerhouse platform."}),"\n",(0,s.jsxs)(n.p,{children:["For more information about GraphQL fundamentals, visit the ",(0,s.jsx)(n.a,{href:"https://graphql.org/learn/",children:"Introduction to GraphQL"})," documentation."]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},7474:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(2155);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);