"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[3472],{5278:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"academy/MasteryTrack/WorkWithData/analytics-processor","title":"Analytics processors","description":"An Analytics Processor is an object that can track analytics for operations and state changes on a set of document models. These analytics can be used to generate bespoke dashboards and reports, specific to the type or implementation of the document model.","source":"@site/docs/academy/02-MasteryTrack/04-WorkWithData/04-analytics-processor.md","sourceDirName":"academy/02-MasteryTrack/04-WorkWithData","slug":"/academy/MasteryTrack/WorkWithData/analytics-processor","permalink":"/academy/MasteryTrack/WorkWithData/analytics-processor","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/04-WorkWithData/04-analytics-processor.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Using subgraphs","permalink":"/academy/MasteryTrack/WorkWithData/UsingSubgraphs"},"next":{"title":"Relational database processor","permalink":"/academy/MasteryTrack/WorkWithData/RelationalDbProcessor"}}');var o=t(5723),r=t(7474);const a={},i="Analytics processors",c={},l=[{value:"Generating an analytics processor with the CLI",id:"generating-an-analytics-processor-with-the-cli",level:2},{value:"<code>ProcessorFactory</code>",id:"processorfactory",level:3},{value:"onStrands",id:"onstrands",level:3},{value:"Learn by example: RwaAnalyticsProcessor",id:"learn-by-example-rwaanalyticsprocessor",level:2},{value:"Learn by example: Document operations",id:"learn-by-example-document-operations",level:2},{value:"Learn by example: Contributor Billing",id:"learn-by-example-contributor-billing",level:2},{value:"<code>IProcessorFactory</code>",id:"iprocessorfactory",level:3},{value:"Dimension Design",id:"dimension-design",level:3},{value:"Query Design",id:"query-design",level:3},{value:"Source Design",id:"source-design",level:3},{value:"<code>IProcessor</code>",id:"iprocessor",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"analytics-processors",children:"Analytics processors"})}),"\n",(0,o.jsx)(n.p,{children:"An Analytics Processor is an object that can track analytics for operations and state changes on a set of document models. These analytics can be used to generate bespoke dashboards and reports, specific to the type or implementation of the document model."}),"\n",(0,o.jsx)(n.h2,{id:"generating-an-analytics-processor-with-the-cli",children:"Generating an analytics processor with the CLI"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ph-cli"})," utility can be used to generate the scaffolding for an Analytics Processor."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"ph generate -p MyAnalyticsProcessor --processor-type analytics\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This will generate two files: a class that implements ",(0,o.jsx)(n.code,{children:"IProcessor"})," and a ",(0,o.jsx)(n.code,{children:"ProcessorFactory"})," function that creates an instance of your processor. We can start with the factory."]}),"\n",(0,o.jsx)(n.h3,{id:"processorfactory",children:(0,o.jsx)(n.code,{children:"ProcessorFactory"})}),"\n",(0,o.jsxs)(n.p,{children:["If one has not already been created, the generator will create an ",(0,o.jsx)(n.code,{children:"index.ts"})," that contains a ",(0,o.jsx)(n.code,{children:"processorFactory"})," function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'export const processorFactory =\n  (module: any) =>\n  (driveId: string): ProcessorRecord[] => {\n    return [\n      {\n        processor: new MyAnalyticsProcessor(module.analyticsStore),\n        filter: {\n          branch: ["main"],\n          documentId: ["*"],\n          scope: ["*"],\n          documentType: ["*"],\n        },\n      },\n    ];\n  };\n'})}),"\n",(0,o.jsx)(n.p,{children:"This function appears complicated at first, but provides for great flexibility."}),"\n",(0,o.jsxs)(n.p,{children:["The outside function (",(0,o.jsx)(n.code,{children:"(module: any) => ProcessorFactory"}),") will be called by the host application (",(0,o.jsx)(n.code,{children:"Reactor"}),", ",(0,o.jsx)(n.code,{children:"Connect"}),", etc) a single time at initialization. This is intended to resolve external dependencies through the ",(0,o.jsx)(n.code,{children:"module"})," object. In the case of this processor, you can see how the ",(0,o.jsx)(n.code,{children:"module"})," object contains the ",(0,o.jsx)(n.code,{children:"analyticsStore"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Next, for each drive created, the returned function (",(0,o.jsx)(n.code,{children:"(driveId:string): ProcessorRecord[]"}),") will be called. This means that this custom function will be responsible for determining which processors are added for each drive. Applications are free to reuse processors or pass in application-specific dependencies in to each processor."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"filter"})," parameter allows a user to tune which updates the processor receives. Usage is straightfoward: each field of the filter parameter can receive one to many patterns. The array for each field describes an ",(0,o.jsx)(n.code,{children:"OR"})," operator. That is, ",(0,o.jsx)(n.code,{children:'["a", "b"]'})," would match ",(0,o.jsx)(n.code,{children:'"a"'})," or ",(0,o.jsx)(n.code,{children:'"b"'}),". However, matches across fields describe an ",(0,o.jsx)(n.code,{children:"AND"})," operator. That is, an update must match on ",(0,o.jsx)(n.code,{children:"branch"})," ",(0,o.jsx)(n.code,{children:"AND"})," ",(0,o.jsx)(n.code,{children:"documentId"})," ",(0,o.jsx)(n.code,{children:"AND"})," ",(0,o.jsx)(n.code,{children:"documentType"})," ",(0,o.jsx)(n.code,{children:"AND"})," ",(0,o.jsx)(n.code,{children:"scope"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Globs are accepted as input, but not regexes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'{\n  branch: ["main"],\n  documentId: ["*"],\n  documentType: ["doc-type-a", "doc-type-b"],\n  scope: ["global", "local"],\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"This example would match updates for:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'("main" branch) AND (any documentId) AND ("doc-type-a" OR "doc-type-b" documentType) AND ("global" OR "local" scope)\n'})}),"\n",(0,o.jsx)(n.h3,{id:"onstrands",children:"onStrands"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"onStrands"})," method is the meat of the processor. This is the function called for all the updates matching the filter. Here is what will be generated for you:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'async onStrands<TDocument extends PHDocument>(\n    strands: InternalTransmitterUpdate<TDocument>[]\n  ): Promise<void> {\n  // nothing to update\n  if (strands.length === 0) {\n    return;\n  }\n\n  const analyticsInputs: AnalyticsSeriesInput[] = [];\n  for (const strand of strands) {\n    if (strand.operations.length === 0) {\n      continue;\n    }\n\n    const firstOp = strand.operations[0];\n    const source = AnalyticsPath.fromString(\n      `ph/${strand.driveId}/${strand.documentId}/${strand.branch}/${strand.scope}`,\n    );\n\n    if (firstOp.index === 0) {\n      await this.clearSource(source);\n    }\n\n    for (const operation of strand.operations) {\n      console.log(">>> ", operation.type);\n\n      // add analytics to the analyticsInputs array\n    }\n  }\n\n  if (analyticsInputs.length > 0) {\n    // batch insert all analytics data\n    await this.analyticsStore.addSeriesValues(analyticsInputs);\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This function provides a list of ",(0,o.jsx)(n.code,{children:"strand"})," objects, each with a list of document-model operations (",(0,o.jsx)(n.code,{children:"InternalOperationUpdate[]"}),") on them. Essentially, it is a list of lists. Each operation will have the previous state of the document and the next state. This allows analytics capture from new state, deltas, or the operations themselves."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Note that on the first operation (given by ",(0,o.jsx)(n.code,{children:"firstOp.index === 0"}),"), it is best practice to clear any previous analytics series for that source. This is so that we do not dual insert operations."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Model-specific code will go where the ",(0,o.jsx)(n.code,{children:"console.log"})," statement currently resides."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["It is best practice to batch insert all updates to the analytics system. In this example, we add all updates to an array of inputs, then insert them all at once. This is optimal over ",(0,o.jsx)(n.code,{children:"await"}),"-ing each separate value."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"learn-by-example-rwaanalyticsprocessor",children:"Learn by example: RwaAnalyticsProcessor"}),"\n",(0,o.jsxs)(n.p,{children:["In the ",(0,o.jsx)(n.code,{children:"reactor-local"})," package, we have implemented a processor for the ",(0,o.jsx)(n.code,{children:"makerdao/rwa-portfolio"})," document type. This is a document model that tracks MakerDAO's Real World Asset (RWA) portfolio. It was initially generated using the ",(0,o.jsx)(n.code,{children:"ph-cli"})," utility."]}),"\n",(0,o.jsx)(n.p,{children:"In the case of the RWA processor, we only want to process updates for the rwa-specific document type, but across all documents. This is why the filter looks like:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'{\n  branch: ["main"],\n  documentId: ["*"],\n  documentType: ["makerdao/rwa-portfolio"],\n  scope: ["global"],\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Inside of the ",(0,o.jsx)(n.code,{children:"onStrands"})," function, past the boilerplate, we see what is essentially a giant switch statement."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'if (operation.type === "CREATE_GROUP_TRANSACTION") {\n  const groupTransaction = operation.input as CreateGroupTransactionInput;\n  if (\n    groupTransaction.type !== "AssetPurchase" &&\n    groupTransaction.type !== "AssetSale" &&\n    groupTransaction.type !== "PrincipalDraw" &&\n    groupTransaction.type !== "PrincipalReturn"\n  ) {\n    continue;\n  }\n\n  // elided\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Since we have knowledge of this specific document model, we can cast the operation input to a specific type. Then, since we only want to track analytics for operations that create transactions, and we can filter out a few transaction types."}),"\n",(0,o.jsx)(n.p,{children:"Below that, we can see how we are capturing analytics data:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'// create good dimensions that we will want to filter on later\nconst dimensions = {\n  asset: AnalyticsPath.fromString(\n    `sky/rwas/assets/t-bills/${fixedIncomeTransaction.assetId}`,\n  ),\n  portfolio: AnalyticsPath.fromString(`sky/rwas/portfolios/${documentId}`),\n};\n\n// create the series values\nconst args = {\n  dimensions,\n  metric: "AssetBalance",\n  source,\n  start: DateTime.fromISO(fixedIncomeTransaction.entryTime),\n  value:\n    groupTransaction.type === "AssetPurchase"\n      ? fixedIncomeTransaction.amount\n      : -fixedIncomeTransaction.amount,\n};\n\nanalyticsInputs.push(args);\n'})}),"\n",(0,o.jsx)(n.p,{children:"With this processor implementation, we can now write queries against processor analytics updates. For example, a GQL query might look like the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-graphql",children:"query Analytics($filter: AnalyticsFilter) {\n  analytics {\n    series(filter: $filter) {\n      start\n      end\n      rows {\n        dimensions {\n          name\n          path\n        }\n        metric\n        value\n        unit\n      }\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"With variables:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "filter": {\n    "granularity": "annual",\n    "start": "2024-01-01",\n    "end": "2025-01-01",\n    "metrics": ["AssetBalance"],\n    "dimensions": [\n      {\n        "name": "asset",\n        "select": "sky/rwas",\n        "lod": 2\n      }\n    ]\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"learn-by-example-document-operations",children:"Learn by example: Document operations"}),"\n",(0,o.jsxs)(n.p,{children:["The RWA processor example pulls information from operation ",(0,o.jsx)(n.em,{children:"inputs"})," to insert analytics data. Another use case might be to capture meta-analytics from the states themselves."]}),"\n",(0,o.jsxs)(n.p,{children:["This processor listens to all documents of type ",(0,o.jsx)(n.code,{children:"powerhouse/document-drive"}),", and since the ",(0,o.jsx)(n.code,{children:"document-drive"})," is itself implemented on top of the document model core systems, this means that we can process all virtual file system operations. This processor count basic usage metrics using document operations and states."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'import { IAnalyticsStore } from "@powerhousedao/reactor-api";\nimport { AnalyticsPath } from "@powerhousedao/reactor-api";\nimport { AnalyticsSeriesInput } from "@powerhousedao/reactor-api";\nimport { InternalTransmitterUpdate, IProcessor } from "document-drive";\nimport {\n  AddFileInput,\n  DeleteNodeInput,\n} from "document-drive/drive-document-model/gen/types";\nimport { PHDocument } from "document-model";\nimport { DateTime } from "luxon";\n\n// iterates over state nodes and retrieves one by id\nconst findNode = (state: any, id: string) => {\n  const { nodes } = state;\n  for (const node of nodes) {\n    if (node.id === id) {\n      return node;\n    }\n  }\n\n  return null;\n};\n\nexport class DriveProcessorProcessor implements IProcessor {\n  constructor(private readonly analyticsStore: IAnalyticsStore) {\n    //\n  }\n\n  async onStrands<TDocument extends PHDocument>(\n    strands: InternalTransmitterUpdate<TDocument>[],\n  ): Promise<void> {\n    if (strands.length === 0) {\n      return;\n    }\n\n    const values: AnalyticsSeriesInput[] = [];\n\n    for (const strand of strands) {\n      const operations = strand.operations;\n      await Promise.all(\n        operations.map((operation) => {\n          const source = AnalyticsPath.fromString(\n            `switchboard/default/${strand.driveId}`,\n          );\n\n          const start = DateTime.fromISO(operation.timestamp);\n          const dimensions: any = {\n            documentType: AnalyticsPath.fromString(\n              `document/type/powerhouse/document-drive`,\n            ),\n          };\n\n          if (operation.index === 0) {\n            this.analyticsStore.clearSeriesBySource(source);\n          }\n\n          switch (operation.type) {\n            case "ADD_FILE": {\n              // count documents of each type (ADD_FILE, input.documentType)\n\n              // lookup node in state\n              const input = operation.input as AddFileInput;\n              const node = findNode(strand.state, input.id);\n              if (!node) {\n                return Promise.resolve();\n              }\n\n              dimensions["kind"] = AnalyticsPath.fromString(\n                `document/kind/${node.kind}`,\n              );\n\n              // increment by adding a 1\n              values.push({\n                source,\n                start,\n                value: 1,\n                metric: "Count",\n                dimensions,\n              });\n\n              break;\n            }\n            case "ADD_FOLDER": {\n              dimensions["kind"] = AnalyticsPath.fromString(\n                "document/kind/folder",\n              );\n\n              // increment by adding a 1\n              values.push({\n                source,\n                start,\n                value: 1,\n                metric: "Count",\n                dimensions,\n              });\n\n              break;\n            }\n            case "DELETE_NODE": {\n              // the operation only contains the id, so lookup deleted item type in previous state\n              const input = operation.input as DeleteNodeInput;\n              const node = findNode(operation.previousState, input.id);\n              if (!node) {\n                return Promise.resolve();\n              }\n\n              dimensions["kind"] = AnalyticsPath.fromString(\n                `document/kind/${node.kind}`,\n              );\n\n              // decrement by adding a -1\n              values.push({\n                source,\n                start,\n                value: -1,\n                metric: "Count",\n                dimensions,\n              });\n\n              break;\n            }\n          }\n        }),\n      );\n    }\n\n    await this.analyticsStore.addSeriesValues(values);\n  }\n\n  async onDisconnect() {}\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"learn-by-example-contributor-billing",children:"Learn by example: Contributor Billing"}),"\n",(0,o.jsx)(n.p,{children:"Here we have documented the entire development process for the contributor billing processor."}),"\n",(0,o.jsx)(n.p,{children:"First, we setup the repository locally."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"$ git clone git@github.com:powerhouse-inc/contributor-billing.git\n$ cd contributor-billing\n~/contributor-billing $ pnpm install\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now we can generate an analytics processor, using default settings."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"~/contributor-billing $ ph generate -p LineItemProcessor --processor-type analytics\n"})}),"\n",(0,o.jsx)(n.p,{children:"We can see what was generated:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"~/contributor-billing $ tree processors\nprocessors\n\u251c\u2500\u2500 index.ts\n\u2514\u2500\u2500 line-item-processor\n    \u2514\u2500\u2500 index.ts\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Note that ",(0,o.jsx)(n.code,{children:"processors/index.ts"})," will only be created if it does not already exist. In this case, you will be responsible for adding the processor to the ",(0,o.jsx)(n.code,{children:"processorFactory"})," function."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"iprocessorfactory",children:(0,o.jsx)(n.code,{children:"IProcessorFactory"})}),"\n",(0,o.jsxs)(n.p,{children:["Let's check out the generated ",(0,o.jsx)(n.code,{children:"index.ts"})," file."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'/**\n * This is a scaffold file meant for customization.\n * Delete the file and run the code generator again to have it reset\n */\n\nimport { ProcessorRecord } from "document-drive/processors/types";\nimport { LineItemProcessorProcessor } from "./line-item-processor/index.js";\n\nexport const processorFactory =\n  (module: any) =>\n  (driveId: string): ProcessorRecord[] => {\n    return [\n      {\n        processor: new LineItemProcessorProcessor(module.analyticsStore),\n        filter: {\n          branch: ["main"],\n          documentId: ["*"],\n          scope: ["*"],\n          documentType: ["*"],\n        },\n      },\n    ];\n  };\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This is described in more detail in the ",(0,o.jsx)(n.a,{href:"#processorfactory",children:"ProcessorFactory"})," section, but for our purposes, we only want our processor to run on our document type, so we should update the filter accordingly."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'filter: {\n  branch: ["main"],\n  documentId: ["*"],\n  scope: ["*"],\n  documentType: ["powerhouse/billing-statement"],\n},\n'})}),"\n",(0,o.jsx)(n.h3,{id:"dimension-design",children:"Dimension Design"}),"\n",(0,o.jsx)(n.p,{children:"Before we get into the meat of the processor, we should be sure to spend some upfront time designing the data we want to query. One way to do this is to start at the end: what do we want to see? In the case of billing statements, we will want to be able to generate reports that show:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Total spent on headcount vs non-headcount"}),"\n",(0,o.jsx)(n.li,{children:"Total spent across all budgets"}),"\n",(0,o.jsx)(n.li,{children:"Stacked bar chart of total spent each month, grouped by budget"}),"\n",(0,o.jsx)(n.li,{children:"Stacked bar chart of total spent each month, grouped by expense category"}),"\n",(0,o.jsx)(n.li,{children:"Total spent each year across all budgets"}),"\n",(0,o.jsx)(n.li,{children:"Total spent each year, grouped by budget"}),"\n",(0,o.jsx)(n.li,{children:"Total spent per month, grouped by budget"}),"\n",(0,o.jsx)(n.li,{children:"Total spent last 30 days, grouped by budget"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"From here, we can deconstruct the different criteria we would like to group data across:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"time period"}),"\n",(0,o.jsx)(n.li,{children:"budget"}),"\n",(0,o.jsx)(n.li,{children:"category"}),"\n",(0,o.jsx)(n.li,{children:"contributor"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The analytics engine gives us a good way to bucket based on time period, so we can focus on the other criteria, which we will specify as ",(0,o.jsx)(n.em,{children:"dimensions"}),". Let's use these dimentions to stub out some of the queries we would want to run, using the ",(0,o.jsx)(n.code,{children:"useAnalyticsQuery"})," hook."]}),"\n",(0,o.jsx)(n.h3,{id:"query-design",children:"Query Design"}),"\n",(0,o.jsx)(n.p,{children:'Let\'s start with "Total spent on headcount vs non-headcount". First, we need to define the time-based criteria.'}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Time and Dates can be very confusing. This is why we use the ",(0,o.jsx)(n.code,{children:"DateTime"})," class from ",(0,o.jsx)(n.code,{children:"luxon"}),"-- see the ",(0,o.jsx)(n.a,{href:"https://moment.github.io/luxon/#/math",children:"luxon docs"})," for a quickstart."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// easy way to get the start and end of the current year\nconst start = DateTime.now().startOf("year");\nconst end = DateTime.now().endOf("year");\n\n// this means we\'ll aggregate results across the entire time period\nconst granularity = "total";\n'})}),"\n",(0,o.jsx)(n.p,{children:"Next, we want to define the metrics we want to analyze. These are the numerical values we will be aggregating over."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// the two numerical values we want to analyze are cash and powt, which are declared separately in the document model\nconst metrics = ["Cash", "Powt"];\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Now, we can define the dimensions we want to group by. We can imagine that we will have a ",(0,o.jsx)(n.code,{children:"contributor"})," dimension, which will tell us whether or not the contributor is headcount: ",(0,o.jsx)(n.code,{children:"/billing-statement/contributor/headcount"})," or ",(0,o.jsx)(n.code,{children:"/billing-statement/contributor/non-headcount"}),"."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["It's best practice to namespace dimensions so that we are sure our data is not colliding with other processors. In this case, we will prepend the ",(0,o.jsx)(n.code,{children:"billing-statement"})," namespace, which is simply a prefix we made up."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'const totalSpendOnHeadcount = useAnalyticsQuery({\n  start,\n  end,\n  granularity,\n  metrics,\n  select: {\n    contributor: "/billing-statement/contributor",\n  },\n  lod: {\n    contributor: 3,\n  },\n});\n'})}),"\n",(0,o.jsxs)(n.p,{children:["It is very important to note that the ",(0,o.jsx)(n.code,{children:"lod"})," parameter is used to specify the level of detail we want to see. In this case, we want to see results grouped by contributor, so we set ",(0,o.jsx)(n.code,{children:"lod"})," to ",(0,o.jsx)(n.code,{children:"3"}),". This means we will get separate metric results for ",(0,o.jsx)(n.code,{children:"/billing-statement/contributor/headcount"})," and ",(0,o.jsx)(n.code,{children:"/billing-statement/contributor/non-headcount"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"We can use these same strategies to create queries for the other criteria we want to group by."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'const totalSpend = useAnalyticsQuery({\n  start,\n  end,\n  granularity: "total", // <--- this means we\'ll get results for the entire time period\n  metrics: ["Cash", "Powt"],\n  select: {\n    budget: "/billing-statement",\n  },\n  lod: {\n    budget: 0, // <--- this means we\'ll get all results lumped together\n  },\n});\n\nconst monthlySpendByBudget = useAnalyticsQuery({\n  start,\n  end,\n  granularity: "monthly", // <--- this means we\'ll get results grouped by month\n  metrics: ["Cash", "Powt"],\n  select: {\n    budget: "/billing-statement/budget",\n  },\n  lod: {\n    budget: 3, // <--- this means we\'ll get results grouped by "/billing-statement/budget/budget1", "/billing-statement/budget/budget2", etc.\n  },\n});\n\nconst monthlySpendByCategory = useAnalyticsQuery({\n  start,\n  end,\n  granularity: "monthly", // <--- this means we\'ll get results grouped by month\n  metrics: ["Cash", "Powt"],\n  select: {\n    category: "/billing-statement/category",\n  },\n  lod: {\n    category: 3, // <--- this means we\'ll get results grouped by "/billing-statement/category/category1", "/billing-statement/category/category2", etc.\n  },\n});\n\nconst yearlySpendByBudget = useAnalyticsQuery({\n  start: DateTime.fromObject({ year: 2022 }),\n  end: DateTime.now().endOf("year"),\n  granularity: "yearly", // <--- this means we\'ll get results grouped by year\n  metrics: ["Cash", "Powt"],\n  select: {\n    budget: "/billing-statement/budget",\n  },\n  lod: {\n    budget: 3, // <--- this means we\'ll get results grouped by "/billing-statement/budget/budget1", "/billing-statement/budget/budget2", etc.\n  },\n});\n\nconst monthlySpendByBudget = useAnalyticsQuery({\n  start,\n  end,\n  granularity: "monthly", // <--- this means we\'ll get results grouped by month\n  metrics: ["Cash", "Powt"],\n  select: {\n    budget: "/billing-statement/budget",\n  },\n  lod: {\n    budget: 3, // <--- this means we\'ll get results grouped by "/billing-statement/budget/budget1", "/billing-statement/budget/budget2", etc.\n  },\n});\n\nconst last30DaysSpendByBudget = useAnalyticsQuery({\n  start: DateTime.now().minus({ days: 30 }),\n  end: DateTime.now(),\n  granularity: "day", // <--- this means we\'ll get results grouped by day\n  metrics: ["Cash", "Powt"],\n  select: {\n    budget: "/billing-statement/budget",\n  },\n  lod: {\n    budget: 3, // <--- this means we\'ll get results grouped by "/billing-statement/budget/budget1", "/billing-statement/budget/budget2", etc.\n  },\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"source-design",children:"Source Design"}),"\n",(0,o.jsxs)(n.p,{children:["The final consideration is the source design. While dimensions and sources both use path syntax, ",(0,o.jsx)(n.em,{children:"the paths are unrelated"}),". That is, a path used in an AnalyticsSeries ",(0,o.jsx)(n.code,{children:"source"})," does not affect a path used in a ",(0,o.jsx)(n.code,{children:"dimension"}),", and vice versa. The ",(0,o.jsx)(n.code,{children:"source"})," attribute of an analytics series is a composable mechanism to track down ",(0,o.jsx)(n.em,{children:"where the data came from"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"This turns out to be an important consideration, as when we query data, we will likely also want to subscribe to a set of sources to later update the data."}),"\n",(0,o.jsx)(n.p,{children:"For instance, say we take our monthly spend by category query:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'const monthlySpendByCategory = useAnalyticsQuery({\n  start,\n  end,\n  granularity: "monthly",\n  metrics: ["Cash", "Powt"],\n  select: {\n    category: "/billing-statement/category",\n  },\n  lod: {\n    category: 3,\n  },\n});\n'})}),"\n",(0,o.jsxs)(n.p,{children:["This gives us the results we're looking for but, by design, there may be many different ",(0,o.jsx)(n.code,{children:"AnalyticsSeries"})," objects that relate to affect this query. Thus, the hook does not know what to listen to. This is where our ",(0,o.jsx)(n.code,{children:"source"})," design comes in. Generally, we will want to relate analytics by drive and/or document."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// this source will match all analytics updates from any document in the drive\nconst driveSource = AnalyticsPath.fromString(\n  `billing-statement/${drive.header.id}`,\n);\n\n// this source will match all analytics updates from a specific document in a drive\nconst documentSource = AnalyticsPath.fromString(\n  `billing-statement/${drive.header.id}/${document.header.id}`,\n);\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'const { state, data: drive } = useSelectedDrive();\n\nconst results = useAnalyticsQuery(\n  {\n    start,\n    end,\n    granularity: "monthly",\n    metrics: ["Cash", "Powt"],\n    select: {\n      category: "/billing-statement/category",\n    },\n    lod: {\n      category: 3,\n    },\n  },\n  {\n    sources: [`/billing-statement/${drive.header.id}/`],\n  },\n);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"iprocessor",children:(0,o.jsx)(n.code,{children:"IProcessor"})}),"\n",(0,o.jsxs)(n.p,{children:["Now that we have designed out our data, we can open up ",(0,o.jsx)(n.code,{children:"line-item-processor/index.ts"})," to add the custom logic we're looking for. This will be in the ",(0,o.jsx)(n.code,{children:"onStrands"})," function."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},7474:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(2155);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);