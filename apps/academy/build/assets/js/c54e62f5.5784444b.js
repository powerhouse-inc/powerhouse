"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[1849],{4640:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"academy/MasteryTrack/DocumentModelCreation/UseTheDocumentModelGenerator","title":"Use the document model generator","description":"In the Powerhouse Document Model development workflow, after specifying your document model\'s state schema and operations within the Connect application and exporting it as a .phdm.zip file, the next crucial step is to translate this specification into a tangible codebase. This is where the Powerhouse Document Model Generator comes into play.","source":"@site/docs/academy/02-MasteryTrack/02-DocumentModelCreation/04-UseTheDocumentModelGenerator.md","sourceDirName":"academy/02-MasteryTrack/02-DocumentModelCreation","slug":"/academy/MasteryTrack/DocumentModelCreation/UseTheDocumentModelGenerator","permalink":"/academy/MasteryTrack/DocumentModelCreation/UseTheDocumentModelGenerator","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/02-DocumentModelCreation/04-UseTheDocumentModelGenerator.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Specify document operations","permalink":"/academy/MasteryTrack/DocumentModelCreation/SpecifyDocumentOperations"},"next":{"title":"Implement document reducers","permalink":"/academy/MasteryTrack/DocumentModelCreation/ImplementDocumentReducers"}}');var i=t(5723),s=t(7474);const r={},c="Use the document model generator",d={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"The command",id:"the-command",level:2},{value:"What happens under the hood? A deep dive into the generated artifacts",id:"what-happens-under-the-hood-a-deep-dive-into-the-generated-artifacts",level:2},{value:"Benefits of using the document model generator",id:"benefits-of-using-the-document-model-generator",level:2},{value:"Practical implementation: Generating the <code>To-do List</code> model",id:"practical-implementation-generating-the-to-do-list-model",level:2},{value:"Prerequisites",id:"prerequisites-1",level:3},{value:"Steps",id:"steps",level:3},{value:"Next steps",id:"next-steps",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"use-the-document-model-generator",children:"Use the document model generator"})}),"\n",(0,i.jsxs)(n.p,{children:["In the Powerhouse Document Model development workflow, after specifying your document model's state schema and operations within the Connect application and exporting it as a ",(0,i.jsx)(n.code,{children:".phdm.zip"})," file, the next crucial step is to translate this specification into a tangible codebase. This is where the Powerhouse Document Model Generator comes into play."]}),"\n",(0,i.jsxs)(n.p,{children:["The Document Model Generator is a powerful command-line tool (",(0,i.jsx)(n.code,{children:"ph generate"}),") that processes your exported ",(0,i.jsx)(n.code,{children:".phdm.zip"})," file and scaffolds the necessary directory structure and foundational code for your document model. It automates the creation of boilerplate code, ensuring consistency, type safety, and adherence to Powerhouse conventions, thereby significantly accelerating the development process."]}),"\n",(0,i.jsx)(n.p,{children:"This document provides a deep dive into using the Document Model Generator, understanding its output, and appreciating its role in the broader context of document model creation."}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"Before you can use the Document Model Generator, ensure you have the following:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Powerhouse CLI (",(0,i.jsx)(n.code,{children:"ph-cmd"}),") Installed:"]})," The generator is part of the Powerhouse CLI. If you haven't installed it, refer to the ",(0,i.jsx)(n.a,{href:"/academy/MasteryTrack/BuilderEnvironment/BuilderTools#installing-the-powerhouse-cli",children:"Builder Tools documentation"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Document Model Specification File (",(0,i.jsx)(n.code,{children:".phdm.zip"}),"):"]})," You must have already defined your document model in Connect and exported it. This file (e.g., ",(0,i.jsx)(n.code,{children:"YourModelName.phdm.zip"}),') contains the GraphQL schema for your document\'s state and operations. This process is typically covered in a preceding step, such as "Define [YourModelName] Document Model."']}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-command",children:"The command"}),"\n",(0,i.jsx)(n.p,{children:"The core command to invoke the Document Model Generator is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ph generate <YourModelName.phdm.zip>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Replace ",(0,i.jsx)(n.code,{children:"<YourModelName.phdm.zip>"})," with the actual filename of your exported document model specification. For instance, if your exported file is named ",(0,i.jsx)(n.code,{children:"Invoice.phdm.zip"}),", the command would be:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ph generate Invoice.phdm.zip\n"})}),"\n",(0,i.jsx)(n.p,{children:"When executed, this command reads and parses the specification file and generates a set of files and directories within your Powerhouse project."}),"\n",(0,i.jsx)(n.h2,{id:"what-happens-under-the-hood-a-deep-dive-into-the-generated-artifacts",children:"What happens under the hood? A deep dive into the generated artifacts"}),"\n",(0,i.jsxs)(n.p,{children:["Running ",(0,i.jsx)(n.code,{children:"ph generate"})," triggers a series of actions that lay the groundwork for your document model's implementation. Let's explore the typical output structure and the significance of each generated component."]}),"\n",(0,i.jsxs)(n.p,{children:["The generator creates a new directory specific to your document model, usually located at:\n",(0,i.jsx)(n.code,{children:"document-models/<YourModelName>/"})]}),"\n",(0,i.jsxs)(n.p,{children:["For example, using ",(0,i.jsx)(n.code,{children:"Invoice.phdm.zip"})," would result in a directory structure under ",(0,i.jsx)(n.code,{children:"document-models/invoice/"}),". Inside this directory, you will find:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"spec.json"})," (or similar JSON representation):"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," This file is a JSON representation of your document model specification, derived directly from the ",(0,i.jsx)(n.code,{children:".phdm.zip"})," file. It contains the parsed schema, operation definitions, document type, and other metadata."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," It serves as the canonical, machine-readable definition of your model within the project, which other tools or processes might reference."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"schema.graphql"}),":"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," This file contains the raw GraphQL Schema Definition Language (SDL) for both the state and operations of your document model, exactly as you defined it in Connect."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," Provides a human-readable reference of the schema and can be useful for quick checks or for tools that might directly consume GraphQL SDL."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["The ",(0,i.jsx)(n.code,{children:"gen/"})," Directory (Generated Code):"]}),"\nThis directory is pivotal as it houses all the code automatically generated by the tool. ",(0,i.jsxs)(n.strong,{children:["You should generally avoid manually editing files within the ",(0,i.jsx)(n.code,{children:"gen/"})," directory"]}),", as they will be overwritten if you regenerate the model.\nKey files within ",(0,i.jsx)(n.code,{children:"gen/"})," include:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"types.ts"}),":"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Contains TypeScript interfaces and type definitions derived from your GraphQL schema. This includes types for your document's state (e.g., ",(0,i.jsx)(n.code,{children:"InvoiceState"}),"), any complex types used within the state (e.g., ",(0,i.jsx)(n.code,{children:"LineItem"}),"), and types for the inputs of each defined operation (e.g., ",(0,i.jsx)(n.code,{children:"AddLineItemInput"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," This is the cornerstone of type safety in your document model implementation. By using these generated types, you ensure that your reducer logic and any client-side interactions adhere to the defined data structures, catching errors at compile-time rather than runtime."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"operations.ts"})," (or ",(0,i.jsx)(n.code,{children:"creators.ts"}),", ",(0,i.jsx)(n.code,{children:"actions.ts"}),"):"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"}),' This file exports "action creator" functions for each operation defined in your schema. These functions take the input parameters for an operation and return a correctly structured action object that can be processed by the reducer system.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," Action creators simplify the process of creating and dispatching operations, reduce the likelihood of errors in action formatting, and improve code readability. For example, instead of manually constructing an action object like ",(0,i.jsx)(n.code,{children:'{ type: "ADD_LINE_ITEM", input: { ... } }'}),", you'd use a function like ",(0,i.jsx)(n.code,{children:"creators.addLineItem({ ... })"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"utils.ts"}),":"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," Often includes utility functions related to your document model. A common utility is a function to create an empty or initial instance of your document (e.g., ",(0,i.jsx)(n.code,{children:"utils.createDocument()"}),"). This is based on the default values and structure defined in your state schema."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," Provides convenient helpers for common tasks, particularly for initializing new documents in tests or application code."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"reducer.ts"})," (or similar, defining the reducer interface/skeleton):"]})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," This file might contain a TypeScript interface or a skeleton object that your actual reducer implementation (in the ",(0,i.jsx)(n.code,{children:"src/"})," directory) will need to conform to. It outlines the expected shape of the reducer map, ensuring that you provide an implementation for every defined operation."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," Guides the implementation of your reducers and helps maintain consistency, ensuring that all defined operations are accounted for."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsxs)(n.strong,{children:["The ",(0,i.jsx)(n.code,{children:"src/"})," Directory (Source Code for Your Implementation):"]}),"\nThis directory is where you, the developer, will write the custom logic for your document model. Unlike the ",(0,i.jsx)(n.code,{children:"gen/"})," directory, files here are meant to be manually edited."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"reducers/"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"your-model-name.ts"})," (e.g., ",(0,i.jsx)(n.code,{children:"invoice.ts"}),"):"]})," This is the most important file you'll work with after generation. It's where you implement the ",(0,i.jsx)(n.strong,{children:"reducer functions"})," for each operation. The generator usually creates a skeleton file with function stubs for each operation, which you then fill in with the actual state transition logic."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," This is the heart of your document model's behavior, defining how the state changes in response to each operation. The next step in the Mastery Track will typically focus on implementing these reducers."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"reducers/tests/"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"your-model-name.test.ts"})," (e.g., ",(0,i.jsx)(n.code,{children:"invoice.test.ts"}),"):"]})," A placeholder or basic test file is often generated here, encouraging you to write unit tests for your reducer logic."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," Emphasizes the importance of testing your document model's core logic to ensure correctness and reliability."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"utils/"})," (optional):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"})," You can create this directory for any custom utility functions specific to your document model's implementation that don't fit directly into the reducers."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Significance:"})," Helps in organizing shared logic or complex computations that might be used across multiple reducers or other parts of your model's ecosystem."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"benefits-of-using-the-document-model-generator",children:"Benefits of using the document model generator"}),"\n",(0,i.jsxs)(n.p,{children:["Leveraging the ",(0,i.jsx)(n.code,{children:"ph generate"})," command offers numerous advantages:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reduced Boilerplate:"})," Automates the creation of repetitive code (type definitions, action creators), saving significant development time and effort."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistency:"})," Enforces a standardized project structure and coding patterns across different document models, making projects easier to understand and maintain."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Safety:"})," The generation of TypeScript types from your GraphQL schema is a massive boon for catching errors early in the development cycle and improving code quality."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Accelerated Development:"})," By providing a ready-to-use scaffold, developers can immediately focus on implementing the core business logic in the reducers, rather than setting up the foundational plumbing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Alignment with Powerhouse Ecosystem:"})," The generated code is designed to integrate seamlessly with other parts of the Powerhouse ecosystem, such as the reducer execution engine and UI components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single Source of Truth:"})," Ensures that your codebase (especially types and action creators) stays synchronized with the document model specification defined in Connect. If the specification changes, regenerating the model will update these components accordingly."]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"practical-implementation-generating-the-to-do-list-model",children:["Practical implementation: Generating the ",(0,i.jsx)(n.code,{children:"To-do List"})," model"]}),"\n",(0,i.jsxs)(n.p,{children:["Now that you understand what the Document Model Generator does, let's walk through the practical steps of using it with our ",(0,i.jsx)(n.code,{children:"To-do List"})," example."]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsxs)("summary",{children:["Tutorial: Generating the ",(0,i.jsx)(n.code,{children:"To-do List"})," document model"]}),(0,i.jsxs)(n.p,{children:["This tutorial assumes you have completed the previous steps in this Mastery Track, where you defined the state schema and operations for the ",(0,i.jsx)(n.code,{children:"To-do List"})," model in Connect and exported it."]}),(0,i.jsx)(n.h3,{id:"prerequisites-1",children:"Prerequisites"}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"ToDoList.phdm.zip"})," file"]}),": You must have the document model specification file exported from Connect. If you do not have this file, please revisit the previous sections on specifying the state schema and operations."]}),"\n"]}),(0,i.jsx)(n.h3,{id:"steps",children:"Steps"}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Place the Specification File in Your Project"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Navigate to the root directory of your Powerhouse project."}),"\n",(0,i.jsxs)(n.li,{children:["Move or copy your ",(0,i.jsx)(n.code,{children:"ToDoList.phdm.zip"})," file into this directory."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Run the Generator Command"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Open your terminal in the root directory of your Powerhouse project."}),"\n",(0,i.jsxs)(n.li,{children:["Execute the ",(0,i.jsx)(n.code,{children:"ph generate"})," command, pointing to your specification file:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ph generate ToDoList.phdm.zip\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Explore the Generated Files"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["After the command completes successfully, you will find a new directory: ",(0,i.jsx)(n.code,{children:"document-models/to-do-list/"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Take a moment to explore its contents, which will match the structure described earlier in this document:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"spec.json"})," and ",(0,i.jsx)(n.code,{children:"schema.graphql"}),": The definition of your model."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"gen/"}),": Type-safe, generated code including ",(0,i.jsx)(n.code,{children:"types.ts"}),", ",(0,i.jsx)(n.code,{children:"operations.ts"}),", etc."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"src/"}),": The skeleton for your implementation, most importantly ",(0,i.jsx)(n.code,{children:"src/reducers/to-do-list.ts"}),", which will contain empty functions for ",(0,i.jsx)(n.code,{children:"addTodoItemOperation"}),", ",(0,i.jsx)(n.code,{children:"updateTodoItemOperation"}),", and ",(0,i.jsx)(n.code,{children:"deleteTodoItemOperation"}),", ready for you to implement."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),(0,i.jsx)(n.p,{children:"With these files generated, you have successfully scaffolded your document model. The project is now set up for you to implement the core business logic."})]}),"\n",(0,i.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsxs)(n.p,{children:["Once the Document Model Generator has successfully scaffolded your project, the immediate next step is to implement the logic for each operation within the generated reducer files (e.g., ",(0,i.jsx)(n.code,{children:"document-models/YourModelName/src/reducers/your-model-name.ts"}),"). This involves taking the current state and the action input, and returning the new state of the document."]}),"\n",(0,i.jsx)(n.p,{children:"Subsequently, you will write unit tests for these reducers to ensure they behave as expected under various conditions. This iterative process of defining, generating, implementing, and testing forms the core loop of document model development in Powerhouse."}),"\n",(0,i.jsx)(n.p,{children:"By understanding the role and output of the Document Model Generator, you are well-equipped to efficiently build robust and maintainable document models within the Powerhouse framework."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},7474:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var o=t(2155);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);