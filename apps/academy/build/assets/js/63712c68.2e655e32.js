"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[3641],{7308:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"academy/MasteryTrack/WorkWithData/RelationalDbProcessor","title":"Relational database processor","description":"In this chapter, we will implement a Todo-List relational database processor. This processor receives processed operations from the reactor and can use the prevState, resultingState, or data from the operations themselves to populate a database.","source":"@site/docs/academy/02-MasteryTrack/04-WorkWithData/05-RelationalDbProcessor.md","sourceDirName":"academy/02-MasteryTrack/04-WorkWithData","slug":"/academy/MasteryTrack/WorkWithData/RelationalDbProcessor","permalink":"/academy/MasteryTrack/WorkWithData/RelationalDbProcessor","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/04-WorkWithData/05-RelationalDbProcessor.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Analytics processors","permalink":"/academy/MasteryTrack/WorkWithData/analytics-processor"},"next":{"title":"Getting started","permalink":"/academy/MasteryTrack/WorkWithData/Analytics Engine/intro"}}');var t=s(5723),o=s(7474);const a={},i="Relational database processor",d={},c=[{value:"Generate the Processor",id:"generate-the-processor",level:2},{value:"Define Your Database Schema",id:"define-your-database-schema",level:2},{value:"Generate Database Types",id:"generate-database-types",level:2},{value:"Configure the Processor Filter",id:"configure-the-processor-filter",level:2},{value:"Implement the Processor Logic",id:"implement-the-processor-logic",level:2},{value:"Expose Data Through a Subgraph",id:"expose-data-through-a-subgraph",level:2},{value:"Generate a Subgraph",id:"generate-a-subgraph",level:3},{value:"Configure the Subgraph",id:"configure-the-subgraph",level:3},{value:"Now query the data via the supergraph.",id:"now-query-the-data-via-the-supergraph",level:2},{value:"<strong>Step 1: Create a Drive (Storage Container)</strong>",id:"step-1-create-a-drive-storage-container",level:3},{value:"<strong>Step 2: Create a Todo Document</strong>",id:"step-2-create-a-todo-document",level:3},{value:"<strong>Step 3: Add Todo Items (Generate Operations)</strong>",id:"step-3-add-todo-items-generate-operations",level:3},{value:"<strong>Step 4: Query Both Data Sources</strong>",id:"step-4-query-both-data-sources",level:3},{value:"<strong>\ud83d\udd0d Data Analysis: Understanding What You&#39;re Seeing</strong>",id:"-data-analysis-understanding-what-youre-seeing",level:3},{value:"Use the Data in Frontend Applications",id:"use-the-data-in-frontend-applications",level:2},{value:"React Hooks",id:"react-hooks",level:3},{value:"Next.js API Route Example",id:"nextjs-api-route-example",level:3},{value:"Summary",id:"summary",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"relational-database-processor",children:"Relational database processor"})}),"\n",(0,t.jsxs)(n.p,{children:["In this chapter, we will implement a ",(0,t.jsx)(n.strong,{children:"Todo-List"})," relational database processor. This processor receives processed operations from the reactor and can use the ",(0,t.jsx)(n.code,{children:"prevState"}),", ",(0,t.jsx)(n.code,{children:"resultingState"}),", or data from the operations themselves to populate a database."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What is a Relational Database Processor?"})}),"\n",(0,t.jsx)(n.p,{children:"A relational database processor is a specialized component that listens to document changes in your Powerhouse application and transforms that data into a traditional relational database format (like PostgreSQL, MySQL, or SQLite). This is incredibly useful for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analytics and Reporting"}),": Running complex SQL queries on your document data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integration"}),": Connecting with existing business intelligence tools"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"generate-the-processor",children:"Generate the Processor"}),"\n",(0,t.jsx)(n.p,{children:"To generate a relational database processor, run the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ph generate --processor todo-indexer --processor-type relationalDb --document-types powerhouse/todolist\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Breaking down this command:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--processor todo-indexer"}),': Creates a processor with the name "todo-indexer"']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--processor-type relationalDb"}),": Specifies we want a relational database processor (vs other types like analytics or webhook processors)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--document-types powerhouse/todolist"}),': Tells the processor to only listen for changes to documents of type "powerhouse/todolist"']}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This command creates a processor named ",(0,t.jsx)(n.code,{children:"todo-indexer"})," of type ",(0,t.jsx)(n.code,{children:"relational database"})," that listens for changes from documents of type ",(0,t.jsx)(n.code,{children:"powerhouse/todolist"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What gets generated:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A processor class file (",(0,t.jsx)(n.code,{children:"processors/todo-indexer/index.ts"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["A database migration file (",(0,t.jsx)(n.code,{children:"processors/todo-indexer/migrations.ts"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["A factory file for configuration (",(0,t.jsx)(n.code,{children:"processors/todo-indexer/factory.ts"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["A schema file for TypeScript types (",(0,t.jsx)(n.code,{children:"processors/todo-indexer/schema.ts"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"define-your-database-schema",children:"Define Your Database Schema"}),"\n",(0,t.jsxs)(n.p,{children:["Next, define your database schema in the ",(0,t.jsx)(n.code,{children:"processors/todo-indexer/migration.ts"})," file."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Understanding Database Migrations"})}),"\n",(0,t.jsx)(n.p,{children:"Migrations are version-controlled database changes that ensure your database schema evolves safely over time. They contain:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"up()"})," function"]}),": Creates or modifies database structures when the processor starts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"down()"})," function"]}),": Safely removes changes when the processor is removed"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This approach ensures your database schema stays in sync across different environments (development, staging, production)."}),"\n",(0,t.jsxs)(n.p,{children:["The migration file contains ",(0,t.jsx)(n.code,{children:"up"})," and ",(0,t.jsx)(n.code,{children:"down"})," functions that are called when the processor is added or removed, respectively."]}),"\n",(0,t.jsx)(n.p,{children:"In the migration.ts file you'll find an example of the todo table default schema:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { type IRelationalDb } from "document-drive/processors/types";\n\nexport async function up(db: IRelationalDb<any>): Promise<void> {\n  // Create table - this runs when the processor starts\n  await db.schema\n    .createTable("todo") // Creates a new table named "todo"\n    .addColumn("task", "varchar(255)") // Text column for the task description (max 255 characters)\n    .addColumn("status", "boolean") // Boolean column for completion status (true/false)\n    .addPrimaryKeyConstraint("todo_pkey", ["task"]) // Makes "task" the primary key (unique identifier)\n    .ifNotExists() // Only create if table doesn\'t already exist\n    .execute(); // Execute the SQL command\n}\n\nexport async function down(db: IRelationalDb<any>): Promise<void> {\n  // Drop table - this runs when the processor is removed\n  await db.schema.dropTable("todo").execute();\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Design Considerations:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We're using ",(0,t.jsx)(n.code,{children:"task"})," as the primary key, which means each task description must be unique"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"varchar(255)"})," limit ensures reasonable memory usage"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"boolean"})," status makes it easy to filter completed vs. incomplete tasks"]}),"\n",(0,t.jsxs)(n.li,{children:["Consider adding timestamps (",(0,t.jsx)(n.code,{children:"created_at"}),", ",(0,t.jsx)(n.code,{children:"updated_at"}),") for audit trails in production applications"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"generate-database-types",children:"Generate Database Types"}),"\n",(0,t.jsx)(n.p,{children:"After defining your database schema, generate TypeScript types for type-safe queries and better IDE support:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ph generate --migration-file processors/todo-indexer/migrations.ts\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why Generate Types?"})}),"\n",(0,t.jsx)(n.p,{children:"TypeScript types provide several benefits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Safety"}),": Catch errors at compile time instead of runtime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IDE Support"}),": Get autocomplete and IntelliSense for your database queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation"}),": Types serve as living documentation of your database structure"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Refactoring"}),": Safe renaming and restructuring of database fields"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Check your ",(0,t.jsx)(n.code,{children:"processors/todo-indexer/schema.ts"})," file after generation - it will contain the TypeScript types for your database schema."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example of generated types:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// This is what gets auto-generated based on your migration\nexport interface Database {\n  todo: {\n    task: string;\n    status: boolean;\n  };\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configure-the-processor-filter",children:"Configure the Processor Filter"}),"\n",(0,t.jsxs)(n.p,{children:["This give you the opportunity to configure the processor filter in ",(0,t.jsx)(n.code,{children:"processors/todo-indexer/factory.ts"}),":"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Understanding Processor Filters"})}),"\n",(0,t.jsx)(n.p,{children:"Filters determine which document changes your processor will respond to. This is crucial for performance and functionality:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"}),": Only process relevant changes to avoid unnecessary work"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Isolation"}),": Different processors can handle different document types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),": Distribute processing load across multiple processors"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import {\n  type ProcessorRecord,\n  type IProcessorHostModule,\n} from "document-drive/processors/types";\nimport { type RelationalDbProcessorFilter } from "document-drive/processors/relational";\nimport { TodoIndexerProcessor } from "./index.js";\n\nexport const todoIndexerProcessorFactory =\n  (module: IProcessorHostModule) =>\n  async (driveId: string): Promise<ProcessorRecord[]> => {\n    // Create a namespace for the processor and the provided drive id\n    // Namespaces prevent data collisions between different drives\n    const namespace = TodoIndexerProcessor.getNamespace(driveId);\n\n    // Create a namespaced db for the processor\n    // This ensures each drive gets its own isolated database tables\n    const store =\n      await module.relationalDb.createNamespace<TodoIndexerProcessor>(\n        namespace,\n      );\n\n    // Create a filter for the processor\n    // This determines which document changes trigger the processor\n    const filter: RelationalDbProcessorFilter = {\n      branch: ["main"], // Only process changes from the "main" branch\n      documentId: ["*"], // Process changes from any document ID (* = wildcard)\n      documentType: ["powerhouse/todolist"], // Only process todolist documents\n      scope: ["global"], // Process global changes (not user-specific)\n    };\n\n    // Create the processor instance\n    const processor = new TodoIndexerProcessor(namespace, filter, store);\n    return [\n      {\n        processor,\n        filter,\n      },\n    ];\n  };\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Filter Options Explained:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"branch"})}),': Which document branches to monitor (usually "main" for production data)']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"documentId"})}),': Specific document IDs to watch ("*" means all documents)']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"documentType"})}),": Document types to process (ensures type safety)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"scope"})}),": Whether to process global changes or user-specific ones"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implement-the-processor-logic",children:"Implement the Processor Logic"}),"\n",(0,t.jsxs)(n.p,{children:["Now implement the actual processor logic in ",(0,t.jsx)(n.code,{children:"processors/todo-indexer/index.ts"})," by copying the code underneath:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Understanding the Processor Lifecycle"})}),"\n",(0,t.jsx)(n.p,{children:"The processor has several key methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"initAndUpgrade()"})}),": Runs once when the processor starts (perfect for running migrations)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"onStrands()"})}),": Runs every time relevant document changes occur (this is where the main logic goes)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"onDisconnect()"})}),": Cleanup when the processor shuts down"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:'What are "Strands"?'}),"\nStrands represent a batch of operations that happened to documents. Each strand contains:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Document ID and metadata"}),"\n",(0,t.jsx)(n.li,{children:"Array of operations (create, update, delete, etc.)"}),"\n",(0,t.jsx)(n.li,{children:"Previous and resulting document states"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { type IRelationalDb } from "document-drive/processors/types";\nimport { RelationalDbProcessor } from "document-drive/processors/relational";\nimport { type InternalTransmitterUpdate } from "document-drive/server/listener/transmitter/internal";\nimport type { ToDoListDocument } from "../document-models/to-do-list/index.js";\n\nimport { up } from "./todo-indexer/migrations.js";\nimport { type DB } from "./todo-indexer/schema.js";\n\n// Define the document type this processor handles\ntype DocumentType = ToDoListDocument;\n\nexport class TodoIndexerProcessor extends RelationalDbProcessor<DB> {\n  // Generate a unique namespace for this processor based on the drive ID\n  // This prevents data conflicts between different drives\n  static override getNamespace(driveId: string): string {\n    // Default namespace: `${this.name}_${driveId.replaceAll("-", "_")}`\n    return super.getNamespace(driveId);\n  }\n\n  // Initialize the processor and run database migrations\n  // This method runs once when the processor starts up\n  override async initAndUpgrade(): Promise<void> {\n    await up(this.relationalDb); // Run the database migration to create tables\n  }\n\n  // Main processing logic - handles incoming document changes\n  // This method is called whenever there are new document operations\n  override async onStrands(\n    strands: InternalTransmitterUpdate<DocumentType>[],\n  ): Promise<void> {\n    // Early return if no changes to process\n    if (strands.length === 0) {\n      return;\n    }\n\n    // Process each strand (batch of changes) individually\n    for (const strand of strands) {\n      // Skip strands with no operations\n      if (strand.operations.length === 0) {\n        continue;\n      }\n\n      // Process each operation within the strand\n      for (const operation of strand.operations) {\n        // Insert a record for each operation into the database\n        // This is a simple example - you might want more sophisticated logic\n        await this.relationalDb\n          .insertInto("todo")\n          .values({\n            // Create a unique task identifier combining document ID, operation index, and type\n            task: `${strand.documentId}-${operation.index}: ${operation.type}`,\n            status: true, // Default to completed status\n          })\n          // Handle conflicts by doing nothing if the task already exists\n          // This prevents duplicate entries if operations are replayed\n          .onConflict((oc) => oc.column("task").doNothing())\n          .execute(); // Execute the database query\n      }\n    }\n  }\n\n  // Cleanup method called when the processor disconnects\n  // Use this for closing connections, clearing caches, etc.\n  async onDisconnect() {\n    // Add any cleanup logic here\n    // For example: await this.relationalDb.destroy();\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"expose-data-through-a-subgraph",children:"Expose Data Through a Subgraph"}),"\n",(0,t.jsx)(n.h3,{id:"generate-a-subgraph",children:"Generate a Subgraph"}),"\n",(0,t.jsx)(n.p,{children:"Generate a new subgraph to expose your processor data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ph generate --subgraph todo\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"What is a Subgraph?"})}),"\n",(0,t.jsx)(n.p,{children:"A subgraph is a GraphQL schema that exposes your processed data to clients. It:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Provides a standardized API for accessing your relational database data"}),"\n",(0,t.jsx)(n.li,{children:"Integrates with the Powerhouse supergraph for unified data access"}),"\n",(0,t.jsx)(n.li,{children:"Supports both queries (reading data) and mutations (modifying data)"}),"\n",(0,t.jsx)(n.li,{children:"Can join data across multiple processors and document types"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configure-the-subgraph",children:"Configure the Subgraph"}),"\n",(0,t.jsxs)(n.p,{children:["Open ",(0,t.jsx)(n.code,{children:"./subgraphs/todo/schema.ts"})," and configure the schema:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { gql } from "graphql-tag";\nimport type { DocumentNode } from "graphql";\n\nexport const schema: DocumentNode = gql`\n  # Define the structure of a todo item as returned by GraphQL\n  type ToDoListEntry {\n    task: String! # The task description (! means required/non-null)\n    status: Boolean! # The completion status (true = done, false = pending)\n  }\n\n  # Define available queries\n  type Query {\n    todos(driveId: ID!): [ToDoListEntry] # Get array of todos for a specific drive\n  }\n`;\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Open ",(0,t.jsx)(n.code,{children:"./subgraphs/todo/resolvers.ts"})," and configure the resolvers:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// subgraphs/search-todos/resolvers.ts\nimport { type Subgraph } from "@powerhousedao/reactor-api";\nimport { type ToDoListDocument } from "document-models/to-do-list/index.js";\nimport { TodoIndexerProcessor } from "../../processors/todo-indexer/index.js";\n\nexport const getResolvers = (subgraph: Subgraph) => {\n  const reactor = subgraph.reactor;\n  const relationalDb = subgraph.relationalDb;\n\n  return {\n    Query: {\n      todos: {\n        // Resolver function for the "todos" query\n        // Arguments: parent object, query arguments, context, GraphQL info\n        resolve: async (_: any, args: { driveId: string }) => {\n          // Query the database using the processor\'s static query method\n          // This gives us access to the namespaced database for the specific drive\n          const todos = await TodoIndexerProcessor.query(\n            args.driveId,\n            relationalDb,\n          )\n            .selectFrom("todo") // Select from the "todo" table\n            .selectAll() // Get all columns\n            .execute(); // Execute the query\n\n          // Transform database results to match GraphQL schema\n          return todos.map((todo) => ({\n            task: todo.task, // Map database "task" column to GraphQL "task" field\n            status: todo.status, // Map database "status" column to GraphQL "status" field\n          }));\n        },\n      },\n    },\n  };\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"now-query-the-data-via-the-supergraph",children:"Now query the data via the supergraph."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Understanding the Supergraph"})}),"\n",(0,t.jsx)(n.p,{children:"The Powerhouse supergraph is a unified GraphQL endpoint that combines:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document Models"}),": Direct access to your Powerhouse documents"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subgraphs"}),": Custom data views from your processors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Built-in APIs"}),": System functionality like authentication and drives"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This unified approach means you can query document state AND processed data in a single request, which is perfect for building rich user interfaces."}),"\n",(0,t.jsxs)(n.p,{children:["The Powerhouse supergraph for any given remote drive or reactor can be found under ",(0,t.jsx)(n.code,{children:"http://localhost:4001/graphql"}),". The gateway / supergraph available on ",(0,t.jsx)(n.code,{children:"/graphql"})," combines all the subgraphs, except for the drive subgraph (which is accessible via ",(0,t.jsx)(n.code,{children:"/d/:driveId"}),"). To access the endpoint, start the reactor and navigate to the URL with ",(0,t.jsx)(n.code,{children:"graphql"})," appended. The following commands explain how you can test & try the supergraph."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Start the reactor:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"ph reactor\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"This will return an endpoint, but you'll need to change the url of the endpoint to the following URL:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"http://localhost:4001/graphql\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The supergraph allows you to both query & mutate data from the same endpoint.\nRead more about ",(0,t.jsx)(n.a,{href:"/academy/MasteryTrack/WorkWithData/UsingSubgraphs",children:"subgraphs"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(n.strong,{children:"Example: Complete Data Flow from Document Operations to Relational Database"})}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Understanding the Complete Data Pipeline"})}),(0,t.jsxs)(n.p,{children:["This comprehensive example demonstrates the ",(0,t.jsx)(n.strong,{children:"entire data flow"})," in a Powerhouse application:"]}),(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Storage Layer"}),": Create a drive (document storage container)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document Layer"}),": Create a todo document and add operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Processing Layer"}),": Watch the relational database processor automatically index changes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"API Layer"}),": Query both original document state AND processed relational data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analysis"}),": Compare the different data representations"]}),"\n"]}),(0,t.jsx)(n.hr,{}),(0,t.jsx)(n.h3,{id:"step-1-create-a-drive-storage-container",children:(0,t.jsx)(n.strong,{children:"Step 1: Create a Drive (Storage Container)"})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What's Happening"}),': Every document needs a "drive" - think of it as a folder or database that contains related documents. This is where your todo documents will live.']}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"mutation DriveCreation($name: String!) {\n  addDrive(name: $name) {\n    name\n  }\n}\n"})}),(0,t.jsx)(n.p,{children:"Variables:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "driveId": "powerhouse",\n  "name": "tutorial"\n}\n'})}),(0,t.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,t.jsx)(n.strong,{children:"Behind the Scenes"}),": This creates a new drive namespace. Your relational database processor will create isolated tables for this drive using the namespace pattern we defined earlier."]}),(0,t.jsx)(n.hr,{}),(0,t.jsx)(n.h3,{id:"step-2-create-a-todo-document",children:(0,t.jsx)(n.strong,{children:"Step 2: Create a Todo Document"})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What's Happening"}),": Now we're creating an actual todo list document inside our drive. This uses the document model we built in previous chapters."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"mutation Mutation($driveId: String, $name: String) {\n  ToDoList_createDocument(driveId: $driveId, name: $name)\n}\n"})}),(0,t.jsx)(n.p,{children:"Variables:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "driveId": "powerhouse",\n  "name": "tutorial"\n}\n'})}),(0,t.jsx)(n.p,{children:"Result:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "data": {\n    "ToDoList_createDocument": "72b73d31-4874-4b71-8cc3-289ed4cfbe2b"\n  }\n}\n'})}),(0,t.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,t.jsx)(n.strong,{children:"Key Insight"}),": The returned UUID (",(0,t.jsx)(n.code,{children:"72b73d31-4874-4b71-8cc3-289ed4cfbe2b"}),") is crucial - this is the document ID that will appear in our processor's database records, linking operations back to their source document. You will receive a different UUID."]}),(0,t.jsx)(n.hr,{}),(0,t.jsx)(n.h3,{id:"step-3-add-todo-items-generate-operations",children:(0,t.jsx)(n.strong,{children:"Step 3: Add Todo Items (Generate Operations)"})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"What's Happening"}),": Each time we add a todo item, we're creating a new ",(0,t.jsx)(n.strong,{children:"operation"})," in the document's history. Our relational database processor is listening for these operations in real-time."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"mutation Mutation(\n  $driveId: String\n  $docId: PHID\n  $input: ToDoList_AddTodoItemInput\n) {\n  ToDoList_addTodoItem(driveId: $driveId, docId: $docId, input: $input)\n}\n"})}),(0,t.jsx)(n.p,{children:"Variables:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "driveId": "powerhouse",\n  "name": "tutorial",\n  "docId": "72b73d31-4874-4b71-8cc3-289ed4cfbe2b",\n  "input": {\n    "id": "1",\n    "text": "complete mutation"\n  }\n}\n'})}),(0,t.jsx)(n.p,{children:"Result:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "data": {\n    "ToDoList_addTodoItem": 1\n  }\n}\n'})}),(0,t.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,t.jsx)(n.strong,{children:"What Happens Next"}),":"]}),(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document Model"}),": Stores the operation and updates document state"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reactor"}),": Broadcasts the operation to all listening processors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Our Processor"}),": Automatically receives the operation and creates a database record"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Database"}),": Now contains: ",(0,t.jsx)(n.code,{children:'"72b73d31-4874-4b71-8cc3-289ed4cfbe2b-0: ADD_TODO_ITEM"'})]}),"\n"]}),(0,t.jsxs)(n.p,{children:["\ud83d\udd04 ",(0,t.jsx)(n.strong,{children:"Repeat this step 2-3 times"})," with different todo items to see multiple operations get processed. Each operation will have an incrementing index (0, 1, 2...)."]}),(0,t.jsx)(n.hr,{}),(0,t.jsx)(n.h3,{id:"step-4-query-both-data-sources",children:(0,t.jsx)(n.strong,{children:"Step 4: Query Both Data Sources"})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"The Power of Dual Data Access"}),": Now we can query BOTH the original document state AND our processed relational data in a single GraphQL request. This demonstrates the flexibility of the Powerhouse architecture."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:"query Query($driveId: ID!) {\n  todos(driveId: $driveId) {\n    task\n    status\n  }\n  ToDoList {\n    getDocuments {\n      state {\n        items {\n          text\n        }\n      }\n    }\n  }\n}\n"})}),(0,t.jsx)(n.p,{children:"Variables:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "driveId": "powerhouse"\n}\n'})}),(0,t.jsx)(n.p,{children:"Response:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "data": {\n    "todos": [\n      {\n        "task": "72b73d31-4874-4b71-8cc3-289ed4cfbe2b-0: ADD_TODO_ITEM",\n        "status": true\n      },\n      {\n        "task": "72b73d31-4874-4b71-8cc3-289ed4cfbe2b-1: ADD_TODO_ITEM",\n        "status": true\n      },\n      {\n        "task": "72b73d31-4874-4b71-8cc3-289ed4cfbe2b-2: ADD_TODO_ITEM",\n        "status": true\n      }\n    ],\n    "ToDoList": {\n      "getDocuments": [\n        {\n          "state": {\n            "items": [\n              {\n                "text": "complete mutation"\n              },\n              {\n                "text": "add another todo"\n              },\n              {\n                "text": "Now check the data"\n              }\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n'})}),(0,t.jsx)(n.hr,{}),(0,t.jsx)(n.h3,{id:"-data-analysis-understanding-what-youre-seeing",children:(0,t.jsx)(n.strong,{children:"\ud83d\udd0d Data Analysis: Understanding What You're Seeing"})}),(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Document Model Data (",(0,t.jsx)(n.code,{children:"ToDoList.getDocuments"}),"):"]})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Current State"}),": Shows the final todo items as they exist in the document"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"User-Friendly"}),': Displays actual todo text like "complete mutation"']}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Real-Time"}),": Always reflects the latest document state"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Limited History"}),": Doesn't show how the document changed over time"]}),"\n"]}),(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Processed Relational Data (",(0,t.jsx)(n.code,{children:"todos"}),"):"]})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Operation History"}),": Shows each individual operation that occurred"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Audit Trail"}),": You can see the sequence (0, 1, 2) of operations"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Analytics Ready"}),": Perfect for counting operations, tracking changes"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Integration Friendly"}),": Standard SQL database that other tools can access"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Less User-Friendly"}),": Shows operation metadata rather than final state"]}),"\n"]}),(0,t.jsx)(n.hr,{}),(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Differences:"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document Query"}),": Gets the current state directly from the document model"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subgraph Query"}),": Gets processed/transformed data from your relational database"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combined Power"}),": You can query both in a single GraphQL request for rich UIs"]}),"\n"]}),(0,t.jsx)(n.p,{children:"This demonstrates how the supergraph provides a unified interface to both your document models and your custom subgraphs, allowing you to query and mutate data from the same endpoint."})]}),"\n",(0,t.jsx)(n.h2,{id:"use-the-data-in-frontend-applications",children:"Use the Data in Frontend Applications"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Integration Options"})}),"\n",(0,t.jsx)(n.p,{children:"Your processed data can now be consumed by any GraphQL client:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"React"}),": Using Apollo Client, urql, or Relay"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Next.js"}),": API routes, getServerSideProps, or app router"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mobile Apps"}),": React Native, Flutter, or native iOS/Android"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Desktop Apps"}),": Electron, Tauri, or other frameworks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Third-party Tools"}),": Any tool that supports GraphQL APIs"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"react-hooks",children:"React Hooks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Coming Soon"}),": This section will cover how to use React hooks to consume your subgraph data in React applications. For now, you can use standard GraphQL clients like Apollo or urql to query your supergraph endpoint."]}),"\n",(0,t.jsx)(n.h3,{id:"nextjs-api-route-example",children:"Next.js API Route Example"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why API Routes?"})}),"\n",(0,t.jsx)(n.p,{children:"Next.js API routes are useful when you need to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Add server-side authentication or authorization"}),"\n",(0,t.jsx)(n.li,{children:"Transform data before sending to the client"}),"\n",(0,t.jsx)(n.li,{children:"Implement caching or rate limiting"}),"\n",(0,t.jsx)(n.li,{children:"Proxy requests to avoid CORS issues"}),"\n",(0,t.jsx)(n.li,{children:"Add logging or monitoring"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// pages/api/todos.ts\nimport { type NextApiRequest, type NextApiResponse } from "next";\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n) {\n  // Only allow GET requests for this endpoint\n  if (req.method !== "GET") {\n    return res.status(405).json({ message: "Method not allowed" });\n  }\n\n  // Extract driveId from query parameters, default to "powerhouse"\n  const { driveId = "powerhouse" } = req.query;\n\n  try {\n    // Query your subgraph or database directly\n    // In production, you might want to add authentication headers here\n    const response = await fetch("http://localhost:4001/graphql", {\n      method: "POST",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify({\n        query: `\n          query GetTodoList($driveId: String) {\n            todoList(driveId: $driveId) {\n              id\n              name\n              completed\n              createdAt\n              updatedAt\n            }\n          }\n        `,\n        variables: { driveId },\n      }),\n    });\n\n    const data = await response.json();\n\n    // Return the todos array from the GraphQL response\n    res.status(200).json(data.data.todoList);\n  } catch (error) {\n    // Log the error for debugging (in production, use proper logging)\n    console.error("Failed to fetch todos:", error);\n\n    // Return a generic error message to the client\n    res.status(500).json({ error: "Failed to fetch todos" });\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"You've successfully created a relational database processor that:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Listens for document changes"})," - Automatically detects when todo documents are modified"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Stores data in a structured database"})," - Transforms document operations into relational data"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Provides type-safe database operations"})," - Uses TypeScript for compile-time safety"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Exposes data through GraphQL"})," - Makes processed data available via a unified API"]}),"\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Can be consumed by frontend applications"})," - Ready for integration with any GraphQL client"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This processor will automatically sync your document changes to the relational database, making the data available for complex queries, reporting, and integration with other systems."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Real-World Applications:"})}),"\n",(0,t.jsx)(n.p,{children:"This pattern is commonly used for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Analytics dashboards"})," showing document usage patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Business intelligence"})," reports on document data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integration"})," with existing enterprise systems"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Search and filtering"})," with complex SQL queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data archival"})," and compliance requirements"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},7474:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var r=s(2155);const t={},o=r.createContext(t);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);