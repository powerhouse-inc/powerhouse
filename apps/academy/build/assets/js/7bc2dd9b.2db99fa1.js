"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[4654],{1159:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"academy/MasteryTrack/DocumentModelCreation/ImplementDocumentReducers","title":"Implement document reducers","description":"The heart of document logic","source":"@site/docs/academy/02-MasteryTrack/02-DocumentModelCreation/05-ImplementDocumentReducers.md","sourceDirName":"academy/02-MasteryTrack/02-DocumentModelCreation","slug":"/academy/MasteryTrack/DocumentModelCreation/ImplementDocumentReducers","permalink":"/academy/MasteryTrack/DocumentModelCreation/ImplementDocumentReducers","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/02-DocumentModelCreation/05-ImplementDocumentReducers.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Use the document model generator","permalink":"/academy/MasteryTrack/DocumentModelCreation/UseTheDocumentModelGenerator"},"next":{"title":"Implement document model tests","permalink":"/academy/MasteryTrack/DocumentModelCreation/ImplementDocumentModelTests"}}');var o=n(5723),r=n(7474);const s={},a="Implement document reducers",c={},d=[{value:"The heart of document logic",id:"the-heart-of-document-logic",level:2},{value:"Recap: The journey to reducer implementation",id:"recap-the-journey-to-reducer-implementation",level:2},{value:"What is a reducer? The core principles",id:"what-is-a-reducer-the-core-principles",level:2},{value:"Key principles guiding reducer implementation:",id:"key-principles-guiding-reducer-implementation",level:3},{value:"Implementing reducer logic: A practical guide",id:"implementing-reducer-logic-a-practical-guide",level:2},{value:"1. Adding an item (e.g., <code>addTodoItemOperation</code>)",id:"1-adding-an-item-eg-addtodoitemoperation",level:3},{value:"2. Updating an item (e.g., <code>updateTodoItemOperation</code>)",id:"2-updating-an-item-eg-updatetodoitemoperation",level:3},{value:"3. Deleting an item (e.g., <code>deleteTodoItemOperation</code>)",id:"3-deleting-an-item-eg-deletetodoitemoperation",level:3},{value:"Leveraging generated types",id:"leveraging-generated-types",level:2},{value:"Practical implementation: Writing the <code>ToDoList</code> reducers",id:"practical-implementation-writing-the-todolist-reducers",level:2},{value:"Implement the operation reducers",id:"implement-the-operation-reducers",level:3},{value:"Reducers and the event sourcing model",id:"reducers-and-the-event-sourcing-model",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"implement-document-reducers",children:"Implement document reducers"})}),"\n",(0,o.jsx)(t.h2,{id:"the-heart-of-document-logic",children:"The heart of document logic"}),"\n",(0,o.jsxs)(t.p,{children:['In our journey through Powerhouse Document Model creation, we\'ve defined the "what" \u2013 the structure of our data (',(0,o.jsx)(t.a,{href:"/academy/MasteryTrack/DocumentModelCreation/SpecifyTheStateSchema",children:"State Schema"}),") and the ways it can be changed (",(0,o.jsx)(t.a,{href:"/academy/MasteryTrack/DocumentModelCreation/SpecifyDocumentOperations",children:"Document Operations"}),"). We've also seen how the ",(0,o.jsx)(t.a,{href:"/academy/MasteryTrack/DocumentModelCreation/UseTheDocumentModelGenerator",children:"Document Model Generator"}),' translates these specifications into a coded scaffold. Now, we arrive at the "how": implementing ',(0,o.jsx)(t.strong,{children:"Document Reducers"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:['Reducers are the core logic units of your document model. They are the functions that take the current state of your document and an operation (an "action"), and then determine the ',(0,o.jsx)(t.em,{children:"new"})," state of the document. They are the embodiment of your business rules and the engine that drives state transitions in a predictable, auditable, and immutable way."]}),"\n",(0,o.jsx)(t.h2,{id:"recap-the-journey-to-reducer-implementation",children:"Recap: The journey to reducer implementation"}),"\n",(0,o.jsx)(t.p,{children:"Before diving into the specifics of writing reducers, let's recall the preceding steps:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"State Schema Definition"}),": You designed the GraphQL ",(0,o.jsx)(t.code,{children:"type"})," definitions for your document's data structure (e.g., ",(0,o.jsx)(t.code,{children:"ToDoListState"}),", ",(0,o.jsx)(t.code,{children:"ToDoItem"}),")."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Document Operation Specification"}),": You defined the GraphQL ",(0,o.jsx)(t.code,{children:"input"})," types that specify the parameters for each allowed modification to your document (e.g., ",(0,o.jsx)(t.code,{children:"AddTodoItemInput"}),", ",(0,o.jsx)(t.code,{children:"UpdateTodoItemInput"}),"). These were then associated with named operations (e.g., ",(0,o.jsx)(t.code,{children:"ADD_TODO_ITEM"}),") in the Connect application."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Code Generation"}),": You used ",(0,o.jsx)(t.code,{children:"ph generate <YourModelName.phdm.zip>"})," to create the necessary TypeScript types, action creators, and, crucially, the skeleton file for your reducers (typically ",(0,o.jsx)(t.code,{children:"document-models/<YourModelName>/src/reducers/<your-model-name>.ts"}),")."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This generated reducer file is our starting point. It will contain function stubs or an object structure expecting your reducer implementations, all typed according to your schema."}),"\n",(0,o.jsx)(t.h2,{id:"what-is-a-reducer-the-core-principles",children:"What is a reducer? The core principles"}),"\n",(0,o.jsxs)(t.p,{children:["In the context of Powerhouse and inspired by patterns like Redux, a reducer is a ",(0,o.jsx)(t.strong,{children:"pure function"})," with the following signature (conceptually):"]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.code,{children:"(currentState, action) => newState"})}),"\n",(0,o.jsx)(t.p,{children:"Let's break down its components and principles:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"currentState"})}),": This is the complete, current state of your document model instance before the operation is applied. It's crucial to treat this as ",(0,o.jsx)(t.strong,{children:"immutable"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"action"})}),": This is an object describing the operation to be performed. It typically has:","\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["A ",(0,o.jsx)(t.code,{children:"type"})," property: A string identifying the operation (e.g., ",(0,o.jsx)(t.code,{children:"'ADD_TODO_ITEM'"}),")."]}),"\n",(0,o.jsxs)(t.li,{children:["An ",(0,o.jsx)(t.code,{children:"input"})," property (or similar, like ",(0,o.jsx)(t.code,{children:"payload"}),"): An object containing the data necessary for the operation, matching the GraphQL ",(0,o.jsx)(t.code,{children:"input"})," type you defined (e.g., ",(0,o.jsx)(t.code,{children:"{ id: '1', text: 'Buy groceries' }"})," for ",(0,o.jsx)(t.code,{children:"AddTodoItemInput"}),")."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"newState"})}),": The reducer must return a ",(0,o.jsx)(t.em,{children:"new"})," state object representing the state after the operation has been applied. If the operation does not result in a state change, the reducer should return the ",(0,o.jsx)(t.code,{children:"currentState"})," object itself."]}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"key-principles-guiding-reducer-implementation",children:"Key principles guiding reducer implementation:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Purity"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Deterministic"}),": Given the same ",(0,o.jsx)(t.code,{children:"currentState"})," and ",(0,o.jsx)(t.code,{children:"action"}),", a reducer must ",(0,o.jsx)(t.em,{children:"always"})," produce the same ",(0,o.jsx)(t.code,{children:"newState"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"No Side Effects"}),": Reducers must not perform any side effects. This means no API calls, no direct DOM manipulation, no ",(0,o.jsx)(t.code,{children:"Math.random()"})," (unless seeded deterministically for specific testing scenarios), and no modification of variables outside their own scope. Their sole job is to compute the next state."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Immutability"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsxs)(t.strong,{children:["Never Mutate ",(0,o.jsx)(t.code,{children:"currentState"})]}),": You must never directly modify the ",(0,o.jsx)(t.code,{children:"currentState"})," object or any of its nested properties."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Always Return a New Object for Changes"}),": If the state changes, you must create and return a brand new object. If the state does not change, you return the original ",(0,o.jsx)(t.code,{children:"currentState"})," object."]}),"\n",(0,o.jsx)(t.li,{children:"This is fundamental to Powerhouse's event sourcing architecture, enabling time travel, efficient change detection, and a clear audit trail. We'll explore techniques for immutability shortly."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Single Source of Truth"}),": The document state managed by reducers is the single source of truth for that document instance. All UI rendering and data queries are derived from this state."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Delegation to specific operation handlers"}),":\nWhile you can write one large reducer that uses a ",(0,o.jsx)(t.code,{children:"switch"})," statement or ",(0,o.jsx)(t.code,{children:"if/else if"})," blocks based on ",(0,o.jsx)(t.code,{children:"action.type"}),", Powerhouse's generated code typically encourages a more modular approach. You'll often implement a separate function for each operation, which are then combined into a main reducer object or map. The ",(0,o.jsx)(t.code,{children:"ph generate"})," command usually sets up this structure for you. For example, in your ",(0,o.jsx)(t.code,{children:"document-models/to-do-list/src/reducers/to-do-list.ts"}),", you'll find an object structure like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'import { ToDoListToDoListOperations } from "../../gen/to-do-list/operations.js"; // Generated type for operations\nimport { ToDoListState } from "../../gen/types.js"; // Generated type for state\n\nexport const reducer: ToDoListToDoListOperations = {\n  addTodoItemOperation(state: ToDoListState, action, dispatch) {\n    // Your logic for ADD_TODO_ITEM\n    // ...\n    return newState;\n  },\n  updateTodoItemOperation(state: ToDoListState, action, dispatch) {\n    // Your logic for UPDATE_TODO_ITEM\n    // ...\n    return newState;\n  },\n  deleteTodoItemOperation(state: ToDoListState, action, dispatch) {\n    // Your logic for DELETE_TODO_ITEM\n    // ...\n    return newState;\n  },\n  // ... other operations\n};\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"ToDoListToDoListOperations"})," type (or similar, depending on your model name) is generated by Powerhouse and ensures your reducer object correctly implements all defined operations. The ",(0,o.jsx)(t.code,{children:"state"})," and ",(0,o.jsx)(t.code,{children:"action"})," parameters within these methods will also be strongly typed based on your schema."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"dispatch"})," parameter is an advanced feature allowing a reducer to trigger subsequent operations. While powerful for complex workflows, it's often not needed for basic operations and can be ignored if unused."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"implementing-reducer-logic-a-practical-guide",children:"Implementing reducer logic: A practical guide"}),"\n",(0,o.jsxs)(t.p,{children:["Let's use our familiar ",(0,o.jsx)(t.code,{children:"ToDoList"})," example to illustrate common patterns. For this example, we'll assume our state schema has been updated to include a ",(0,o.jsx)(t.code,{children:"stats"})," object to track the number of total, checked, and unchecked items."]}),"\n",(0,o.jsxs)(t.p,{children:["Our ",(0,o.jsx)(t.code,{children:"ToDoListState"})," now looks like this:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"interface ToDoItem {\n  id: string;\n  text: string;\n  checked: boolean;\n}\n\ninterface ToDoListStats {\n  total: number;\n  checked: number;\n  unchecked: number;\n}\n\ninterface ToDoListState {\n  items: ToDoItem[];\n  stats: ToDoListStats;\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["And our action creators (from ",(0,o.jsx)(t.code,{children:"../../gen/creators"})," or ",(0,o.jsx)(t.code,{children:"../../gen/operations.js"}),") provide actions like:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"actions.addTodoItem({ id: 'some-id', text: 'New Task' })"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"actions.updateTodoItem({ id: 'item-id', text: 'Updated Task Text', checked: true })"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"actions.deleteTodoItem({ id: 'item-id' })"})}),"\n"]}),"\n",(0,o.jsxs)(t.h3,{id:"1-adding-an-item-eg-addtodoitemoperation",children:["1. Adding an item (e.g., ",(0,o.jsx)(t.code,{children:"addTodoItemOperation"}),")"]}),"\n",(0,o.jsxs)(t.p,{children:["To add a new item to the ",(0,o.jsx)(t.code,{children:"items"})," array immutably:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"addTodoItemOperation(state: ToDoListState, action: /* AddTodoItemActionType */ any, dispatch) {\n  const newItem: ToDoItem = {\n    id: action.input.id,\n    text: action.input.text,\n    checked: false, // New items default to unchecked\n  };\n\n  // Return a new state object\n  return {\n    ...state, // Copy all existing properties from the current state\n    items: [...state.items, newItem], // Create a new items array: spread existing items, add the new one\n  };\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Explanation"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We use the spread operator (",(0,o.jsx)(t.code,{children:"...state"}),") to copy top-level properties from the old state into the new state object."]}),"\n",(0,o.jsxs)(t.li,{children:["For the ",(0,o.jsx)(t.code,{children:"items"})," array, we create a ",(0,o.jsx)(t.em,{children:"new"})," array by spreading the existing ",(0,o.jsx)(t.code,{children:"state.items"})," and then appending the ",(0,o.jsx)(t.code,{children:"newItem"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.h3,{id:"2-updating-an-item-eg-updatetodoitemoperation",children:["2. Updating an item (e.g., ",(0,o.jsx)(t.code,{children:"updateTodoItemOperation"}),")"]}),"\n",(0,o.jsxs)(t.p,{children:["To update an existing item in the ",(0,o.jsx)(t.code,{children:"items"})," array immutably:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"updateTodoItemOperation(state: ToDoListState, action: /* UpdateTodoItemActionType */ any, dispatch) {\n  const { id, text, checked } = action.input;\n\n  // Return a new state object\n  return {\n    ...state,\n    items: state.items.map(item => {\n      if (item.id === id) {\n        // This is the item to update. Return a *new* item object.\n        return {\n          ...item, // Copy existing properties of the item\n          // Update only fields that are provided in the action input\n          ...(text !== undefined && { text: text }),\n          ...(checked !== undefined && { checked: checked }),\n        };\n      }\n      // This is not the item we're looking for, return it unchanged.\n      return item;\n    }),\n  };\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Explanation"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We use the ",(0,o.jsx)(t.code,{children:"map"})," array method, which always returns a ",(0,o.jsx)(t.em,{children:"new"})," array."]}),"\n",(0,o.jsxs)(t.li,{children:["For the item that matches ",(0,o.jsx)(t.code,{children:"action.input.id"}),", we create a new item object using the spread operator (",(0,o.jsx)(t.code,{children:"...item"}),") and then overwrite the properties (",(0,o.jsx)(t.code,{children:"text"}),", ",(0,o.jsx)(t.code,{children:"checked"}),") that are present in ",(0,o.jsx)(t.code,{children:"action.input"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:["The conditional spread (",(0,o.jsx)(t.code,{children:"...(condition && { property: value })"}),") is a concise way to only include a property in the new object if its corresponding input value is provided. This elegantly handles partial updates."]}),"\n",(0,o.jsx)(t.li,{children:"If an item doesn't match the ID, it's returned as is."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Error Handling Note"}),": In a real application, you might want to add a check to see if an item with ",(0,o.jsx)(t.code,{children:"action.input.id"})," actually exists. If not, you could throw an error or handle it according to your application's requirements:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"// Inside updateTodoItemOperation, before returning:\nconst itemToUpdate = state.items.find((item) => item.id === action.input.id);\nif (!itemToUpdate) {\n  // Option 1: Throw an error (Powerhouse runtime might catch this)\n  throw new Error(`Item with id ${action.input.id} not found.`);\n  // Option 2: Return current state (no change)\n  // return state;\n}\n// ... proceed with map\n"})}),"\n",(0,o.jsxs)(t.h3,{id:"3-deleting-an-item-eg-deletetodoitemoperation",children:["3. Deleting an item (e.g., ",(0,o.jsx)(t.code,{children:"deleteTodoItemOperation"}),")"]}),"\n",(0,o.jsxs)(t.p,{children:["To remove an item from the ",(0,o.jsx)(t.code,{children:"items"})," array immutably:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"deleteTodoItemOperation(state: ToDoListState, action: /* DeleteTodoItemActionType */ any, dispatch) {\n  const { id } = action.input;\n\n  // Return a new state object\n  return {\n    ...state,\n    items: state.items.filter(item => item.id !== id), // Create a new array excluding the item to delete\n  };\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Explanation"}),":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["We use the ",(0,o.jsx)(t.code,{children:"filter"})," array method, which returns a ",(0,o.jsx)(t.em,{children:"new"})," array containing only the elements for which the callback function returns ",(0,o.jsx)(t.code,{children:"true"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"leveraging-generated-types",children:"Leveraging generated types"}),"\n",(0,o.jsxs)(t.p,{children:["As highlighted in ",(0,o.jsx)(t.a,{href:"/academy/MasteryTrack/DocumentModelCreation/UseTheDocumentModelGenerator",children:"Using the Document Model Generator"}),", ",(0,o.jsx)(t.code,{children:"ph generate"})," produces TypeScript types for your state (e.g., ",(0,o.jsx)(t.code,{children:"ToDoListState"}),", ",(0,o.jsx)(t.code,{children:"ToDoItem"}),") and the inputs for your operations (e.g., ",(0,o.jsx)(t.code,{children:"AddTodoItemInput"}),", ",(0,o.jsx)(t.code,{children:"UpdateTodoItemInput"}),")."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Always use these generated types in your reducer implementations!"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"import {\n  ToDoListState,\n  AddTodoItemInput, // Generated input type\n  // ... other types\n} from \"../../gen/types.js\";\nimport { ToDoListToDoListOperations } from \"../../gen/to-do-list/operations.js\"; // Generated operations type\n\n// Define the type for the action more explicitly if needed, or rely on inferred types\n// from ToDoListToDoListOperations. For complex actions, defining specific action types can be beneficial.\n// For example:\n// interface AddTodoItemAction {\n//   type: 'ADD_TODO_ITEM'; // Or the specific string constant used by the action creator\n//   input: AddTodoItemInput;\n// }\n\nexport const reducer: ToDoListToDoListOperations = {\n  addTodoItemOperation(\n    state: ToDoListState,\n    action: { input: AddTodoItemInput /* plus type property */ },\n    dispatch,\n  ) {\n    // Now 'action.input.text' and 'action.input.id' are type-checked\n    const newItem = {\n      id: action.input.id,\n      text: action.input.text,\n      checked: false,\n    };\n    return {\n      ...state,\n      items: [...state.items, newItem],\n    };\n  },\n  // ... other reducers\n};\n"})}),"\n",(0,o.jsx)(t.p,{children:"Using these types provides:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Compile-time safety"}),": Catch errors related to incorrect property names or data types before runtime."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Autocompletion and IntelliSense"}),": Improved developer experience in your IDE."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Clearer code"}),": Types serve as documentation for the expected data structures."]}),"\n"]}),"\n",(0,o.jsxs)(t.h2,{id:"practical-implementation-writing-the-todolist-reducers",children:["Practical implementation: Writing the ",(0,o.jsx)(t.code,{children:"ToDoList"})," reducers"]}),"\n",(0,o.jsxs)(t.p,{children:["Now that you understand the principles, let's put them into practice by implementing the reducers for our ",(0,o.jsx)(t.code,{children:"ToDoList"})," document model."]}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"Tutorial: Implementing the ToDoList reducers"}),(0,o.jsxs)(t.p,{children:["This tutorial assumes you have followed the steps in the previous chapters, especially using ",(0,o.jsx)(t.code,{children:"ph generate ToDoList.phdm.zip"})," to scaffold your document model's code."]}),(0,o.jsx)(t.h3,{id:"implement-the-operation-reducers",children:"Implement the operation reducers"}),(0,o.jsxs)(t.p,{children:["Navigate to ",(0,o.jsx)(t.code,{children:"document-models/to-do-list/src/reducers/to-do-list.ts"}),". The generator will have created a skeleton file. Replace its contents with the following logic."]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"import { ToDoListToDoListOperations } from \"../../gen/to-do-list/operations.js\";\nimport { ToDoListState } from \"../../gen/types.js\"; // Assuming this now includes the 'stats' object\n\n// REMARKS: This is our main reducer object. It implements all operations defined in the schema.\n// The ToDoListToDoListOperations type is auto-generated from our GraphQL specification and ensures type safety.\nexport const reducer: ToDoListToDoListOperations = {\n  // REMARKS: The addTodoItemOperation adds a new item and updates our tracking statistics.\n  // - state: The current document state. Powerhouse uses a library like Immer.js,\n  //   so you can write code that looks like it's mutating the state directly.\n  //   Behind the scenes, Powerhouse ensures this results in an immutable update.\n  // - action: Contains the operation's 'type' and 'input' data from the client.\n  // - dispatch: A function to trigger subsequent operations (advanced, not used here).\n  addTodoItemOperation(state, action, dispatch) {\n    // REMARKS: We update our statistics for total and unchecked items.\n    state.stats.total += 1;\n    state.stats.unchecked += 1;\n\n    // REMARKS: We push the new to-do item into the items array.\n    // The data for the new item comes from the operation's input.\n    state.items.push({\n      id: action.input.id,\n      text: action.input.text,\n      checked: false, // New items always start as unchecked.\n    });\n  },\n\n  // REMARKS: The updateTodoItemOperation modifies an existing to-do item.\n  // It handles partial updates for text and checked status.\n  updateTodoItemOperation(state, action, dispatch) {\n    // REMARKS: First, we find the specific item we want to update using its ID.\n    const item = state.items.find((item) => item.id === action.input.id);\n\n    // REMARKS: It's good practice to handle cases where the item might not be found.\n    if (!item) {\n      throw new Error(`Item with id ${action.input.id} not found`);\n    }\n\n    // REMARKS: We only update the text if it was provided in the input.\n    // This allows for partial updates (e.g., just checking an item without changing its text).\n    if (action.input.text) {\n      item.text = action.input.text;\n    }\n\n    // REMARKS: When the checked status changes, we also update our statistics.\n    // We check for `true` and `false` explicitly.\n    if (action.input.checked) {\n      // This is true only if action.input.checked is true\n      // Note: This assumes the item was previously unchecked. For a more robust implementation,\n      // you could check `if (item.checked === false)` before updating stats to prevent inconsistencies.\n      state.stats.unchecked -= 1;\n      state.stats.checked += 1;\n      item.checked = action.input.checked;\n    }\n    if (action.input.checked === false) {\n      // Note: This assumes the item was previously checked.\n      state.stats.unchecked += 1;\n      state.stats.checked -= 1;\n      item.checked = action.input.checked;\n    }\n  },\n\n  // REMARKS: The deleteTodoItemOperation removes an item from the list.\n  deleteTodoItemOperation(state, action, dispatch) {\n    // REMARKS: Before removing the item, we find it to determine its checked status.\n    // This is necessary to correctly decrement our statistics.\n    const item = state.items.find((item) => item.id === action.input.id);\n\n    // REMARKS: We always decrement the total count.\n    state.stats.total -= 1;\n\n    // REMARKS: We then decrement the 'checked' or 'unchecked' count based on the item's status.\n    if (item?.checked) {\n      // This is shorthand for item?.checked === true\n      state.stats.checked -= 1;\n    }\n    if (item?.checked === false) {\n      state.stats.unchecked -= 1;\n    }\n\n    // REMARKS: Finally, we create a new 'items' array that excludes the deleted item.\n    // Assigning to 'state.items' is handled by Powerhouse to produce a new immutable state.\n    state.items = state.items.filter((item) => item.id !== action.input.id);\n  },\n};\n"})})]}),"\n",(0,o.jsx)(t.h2,{id:"reducers-and-the-event-sourcing-model",children:"Reducers and the event sourcing model"}),"\n",(0,o.jsx)(t.p,{children:'Every time a reducer processes an operation and returns a new state, Powerhouse records the original operation (the "event") in an append-only log associated with the document instance. The current state of the document is effectively a "fold" or "reduction" of all past events, applied sequentially by the reducers.'}),"\n",(0,o.jsx)(t.p,{children:"This is why purity and immutability are so critical:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Purity"})," ensures that replaying the same sequence of events will always yield the exact same final state."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Immutability"})," ensures that each event clearly defines a discrete state transition, making it easy to audit changes and understand the document's history."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(t.p,{children:"Implementing document reducers is where you breathe life into your document model's specification. By adhering to the principles of purity and immutability, and by leveraging the type safety provided by Powerhouse's code generation, you can build predictable, testable, and maintainable business logic. These reducers form the immutable backbone of your document's state management, perfectly aligning with the event sourcing architecture that underpins Powerhouse."}),"\n",(0,o.jsx)(t.p,{children:"With your reducers implemented, your document model is now functionally complete from a data manipulation perspective. The next chapter covers how to write tests for this logic to ensure its correctness and reliability."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},7474:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(2155);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);