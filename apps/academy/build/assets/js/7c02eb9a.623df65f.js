"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[4212],{622:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/paths-2-20bb725c6968950a303c0714e0f71ecd.jpg"},3501:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/overview-4-63eab4531a17b9a3252c7dac14d68b8e.jpg"},3654:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/overview-3-de5fd92a146373fec3022f04269094cb.jpg"},5770:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"academy/MasteryTrack/WorkWithData/Analytics Engine/intro","title":"Getting started","description":"Introduction","source":"@site/docs/academy/02-MasteryTrack/04-WorkWithData/06-Analytics Engine/intro.md","sourceDirName":"academy/02-MasteryTrack/04-WorkWithData/06-Analytics Engine","slug":"/academy/MasteryTrack/WorkWithData/Analytics Engine/intro","permalink":"/academy/MasteryTrack/WorkWithData/Analytics Engine/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/02-MasteryTrack/04-WorkWithData/06-Analytics Engine/intro.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"sidebar_position":0},"sidebar":"academySidebar","previous":{"title":"Relational database processor","permalink":"/academy/MasteryTrack/WorkWithData/RelationalDbProcessor"},"next":{"title":"Typescript API","permalink":"/academy/MasteryTrack/WorkWithData/Analytics Engine/typescript/"}}');var n=t(5723),a=t(7474);const r={sidebar_position:0},o="Getting started",l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Overview",id:"overview",level:2},{value:"Series and dimensions",id:"series-and-dimensions",level:3},{value:"Structure vs. reporting",id:"structure-vs-reporting",level:3},{value:"Paths",id:"paths",level:3},{value:"LODs",id:"lods",level:3},{value:"Granularity",id:"granularity",level:3},{value:"Available options",id:"available-options",level:4},{value:"How granularity affects query results",id:"how-granularity-affects-query-results",level:4},{value:"Cheatsheet",id:"cheatsheet",level:2},{value:"Next steps",id:"next-steps",level:2}];function h(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"getting-started",children:"Getting started"})}),"\n",(0,n.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsxs)(s.p,{children:["Welcome to the Powerhouse Analytics Engine Documentation. This engine is a powerful time-series analytics system, written in Typescript with an optional GraphQL interface on top. It is designed to run ",(0,n.jsx)(s.em,{children:"anywhere"}),". Browsers, server environments, CLI tools, etc."]}),"\n",(0,n.jsxs)(s.p,{children:["This documentation serves as a guide for Typescript and GraphQL API usage, not library development. For documentation on how to build or contribute to this project, see our ",(0,n.jsx)(s.a,{href:"https://github.com/powerhouse-inc/analytics-engine/blob/main/README.md",children:"README"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"high-level",src:t(8734).A+"",width:"1405",height:"711"})}),"\n",(0,n.jsxs)(s.p,{children:["This system can be broken up into several major systems: ",(0,n.jsx)(s.strong,{children:"queries"}),", ",(0,n.jsx)(s.strong,{children:"engine components"})," (including filters and aggregation), and ",(0,n.jsx)(s.strong,{children:"storage"}),". Each of these systems have detailed documentation, but it is most helpful to start with a holistic understanding of the major pieces of data: series and dimensions."]}),"\n",(0,n.jsx)(s.h3,{id:"series-and-dimensions",children:"Series and dimensions"}),"\n",(0,n.jsxs)(s.p,{children:["All metrics are collected and stored using only two objects: ",(0,n.jsx)(s.strong,{children:"AnalyticsSeries"})," and ",(0,n.jsx)(s.strong,{children:"AnalyticsDimension"}),". To be a successful consumer of this system, It is vital to understand the intent of these two pieces of data."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"1",src:t(7700).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsxs)(s.p,{children:["Typical time-series databases (like ",(0,n.jsx)(s.a,{href:"https://graphiteapp.org/",children:"Graphite"}),") usually store data as ",(0,n.jsx)(s.code,{children:"(time, value)"})," tuples: relating an explicit value to an explicit time. In the Web3 space, we have learned through ",(0,n.jsx)(s.a,{href:"https://fusion.sky.money/",children:"real uses cases with MakerDAO"}),", that this isn't quite flexible enough for Web3 constructs."]}),"\n",(0,n.jsxs)(s.p,{children:["Instead, the time series values in this system are given by a value paired with a ",(0,n.jsx)(s.em,{children:"time interval"}),". That is, values have a start and an end. This allows for interpolation functions across a time interval, like a linear change."]}),"\n",(0,n.jsx)(s.p,{children:"Of course, the default is simply a constant function, giving a constant value inside of the time interval."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"4",src:t(3501).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsx)(s.p,{children:'This means that when we want to query data, we are querying over intervals and can query for either "running totals" or changes (deltas) over an interval.'}),"\n",(0,n.jsx)(s.p,{children:"In the example above, querying over different intervals returns different totals and deltas depending on interval. This is another difference with typical time-series databases: deltas as first class. The analytics system takes care of this aggregation for users."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"2",src:t(9792).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsx)(s.p,{children:"In real use cases, we generally have many data sets running in parallel. In this example, we have two related systems, both inserting data. Some of the intervals overlap, some don't, and we see some gaps in the data as well."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"3",src:t(3654).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsx)(s.p,{children:"The question is: how do we query and aggregate this related data? We could potentially make multiple queries and do this ourselves, but it would require a good understanding of the implementation details."}),"\n",(0,n.jsxs)(s.p,{children:["This is where the ",(0,n.jsx)(s.strong,{children:"AnalyticsDimension"})," object comes into play."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"4",src:t(6227).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsx)(s.p,{children:"While there will be thousands or millions of series objects, there will be far fewer referenced dimension objects. Dimensions allow users to decorate series objects with query and aggregation information. These objects are shared across all the series records."}),"\n",(0,n.jsxs)(s.p,{children:["Visually, you can think of series as values running up and down, while dimensions allow for query and aggregation ",(0,n.jsx)(s.em,{children:"across"})," the different series objects."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"6",src:t(5983).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsx)(s.h3,{id:"structure-vs-reporting",children:"Structure vs. reporting"}),"\n",(0,n.jsxs)(s.p,{children:["The Series and Dimensions objects give control over how metric data is defined and related. That is, they define the ",(0,n.jsx)(s.strong,{children:"structure"})," of data. Three new concepts: Paths, LODs, and granularity, are parameters used to define how the system should ",(0,n.jsx)(s.em,{children:"report"})," the data."]}),"\n",(0,n.jsx)(s.h3,{id:"paths",children:"Paths"}),"\n",(0,n.jsxs)(s.p,{children:["Let's start with paths. A ",(0,n.jsx)(s.code,{children:"path"})," is a field on an ",(0,n.jsx)(s.code,{children:"AnalyticsDimension"})," that describes the ",(0,n.jsx)(s.em,{children:"specificity of the query"}),"."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"1",src:t(6569).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsxs)(s.p,{children:['In this example, inspired by real MakerDAO metrics, we have a number of series values that have been decorated with a couple of dimensions. Dimensions, as we have discussed, have a name like "budget". They also have this ',(0,n.jsx)(s.code,{children:"path"})," field, which looks like a URI or directory hierarchy: a string made up of smaller strings separated by ",(0,n.jsx)(s.code,{children:"/"}),"s."]}),"\n",(0,n.jsx)(s.p,{children:"Note that, some series values have been decorated with multiple dimensions, some with a single dimension, and some have not been decorated with either."}),"\n",(0,n.jsxs)(s.p,{children:["It's clear enough that when we request budget data for a specific MIP dimension, like the purple one (",(0,n.jsx)(s.code,{children:"/atlas/mip40/MIP40c3SP61"}),"), we should be getting totals and deltas across only the purple series objects."]}),"\n",(0,n.jsxs)(s.p,{children:["But what if we want to query across everything related to ",(0,n.jsx)(s.code,{children:"mip40"}),"?"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"2",src:t(622).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsxs)(s.p,{children:["This is the beauty of dimension paths. All we need to do is use a ",(0,n.jsx)(s.code,{children:"path"})," to describe the ",(0,n.jsx)(s.em,{children:"specificity"})," of the query. In this case, we use ",(0,n.jsx)(s.code,{children:"/atlas/mip40"}),", which will match all dimensions that start with ",(0,n.jsx)(s.code,{children:"/atlas/mip40"}),", which in turn matches all series values related to to those dimensions."]}),"\n",(0,n.jsx)(s.h3,{id:"lods",children:"LODs"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"LOD"}),' is short for "level of detail", and it is not a field found on either the series or dimension objects. It is a parameter used in queries only, to determine how results are aggregated across dimensions.']}),"\n",(0,n.jsx)(s.p,{children:"Let's look at our example again."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"a",src:t(622).A+"",width:"2758",height:"1450"})}),"\n",(0,n.jsxs)(s.p,{children:["Here we have asked for a report on the ",(0,n.jsx)(s.code,{children:"budget"})," metric, with path ",(0,n.jsx)(s.code,{children:"/atlast/mip40"}),". The path determines the specificity of the query, and LOD determines how to aggregate results."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"lod",src:t(5914).A+"",width:"2677",height:"1494"})}),"\n",(0,n.jsxs)(s.p,{children:["An LOD of ",(0,n.jsx)(s.code,{children:"0"})," will group all results together in a single value. An LOD of ",(0,n.jsx)(s.code,{children:"1"})," will group results by the first part of the path, in this case: ",(0,n.jsx)(s.code,{children:"/atlas"}),". And so on for an LOD of 2 or 3. This means that increasing the LOD will increase the number of values retieved as the system needs to aggregate with higher specificity."]}),"\n",(0,n.jsxs)(s.p,{children:["An LOD greater than the number of parts of the path (in this case, 4 or more) will append a ",(0,n.jsx)(s.code,{children:"/*"})," for each additional path part to the end of the grouped results but will provide the same results as the highest level of detail."]}),"\n",(0,n.jsx)(s.h3,{id:"granularity",children:"Granularity"}),"\n",(0,n.jsxs)(s.p,{children:["While LODs allow you to aggregate series data across dimensions, ",(0,n.jsx)(s.em,{children:"granularity"})," refers to how data is aggregated over time. It determines the time span each data point or record covers. Choosing the right granularity is crucial for meaningful analysis, as it affects the interpretation and insights that can be drawn from the data."]}),"\n",(0,n.jsx)(s.h4,{id:"available-options",children:"Available options"}),"\n",(0,n.jsx)(s.p,{children:"The analytics engine supports various granularity options, each suitable for different types of analysis:"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"total"}),": Provides a cumulative view of data over the entire time frame available in the dataset. Best used for overall summaries and long-term analysis."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"annual"}),": Aggregates data on a yearly basis. Ideal for year-over-year comparisons and annual trend analysis."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"semiAnnual"})," : Breaks down data into six-month periods. Useful for understanding bi-annual trends and patterns."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"quarterly"}),": Divides data into quarters, offering insights into seasonal trends or quarter-over-quarter performance."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"monthly"})," : Monthly granularity is useful for a more detailed view of trends and patterns, particularly useful for operational planning and monitoring."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"weekly"})," : Provides weekly data aggregation, which is helpful for short-term performance tracking and operational adjustments.\ndaily: Offers a day-to-day breakdown, ideal for detailed analysis of daily operations or events."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"hourly"}),": The most granular level, providing insights into hourly fluctuations. Useful in scenarios where short-term data spikes or dips are significant."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h4,{id:"how-granularity-affects-query-results",children:"How granularity affects query results"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Data Volume: Higher granularity (like hourly or daily) results in a larger volume of data points, providing more detailed insights but potentially leading to more complex analysis. Lower granularity (like annual or total) simplifies the data into fewer, broader data points."}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Trend Analysis: Finer granularity helps in identifying short-term trends and anomalies, whereas coarser granularity is better for long-term trend analysis and strategic planning.\nPerformance Impact: Queries with finer granularity might be more resource-intensive and take longer to execute due to the larger number of data points processed."}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Contextual Relevance: The choice of granularity should match the context of the analysis. For instance, financial planning might prefer annual or quarterly granularity, while operational monitoring might require daily or hourly data."}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:"Comparative Analysis: Different granularity levels can be used for comparative analysis, such as comparing detailed daily data (through daily granularity) against broader monthly trends (using monthly granularity) to understand day-to-day variations within the context of a monthly overview."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"In summary, the choice of granularity in your query significantly influences the scope, detail, and utility of the analytics results. It is important to align the granularity with the specific analytical objectives and the nature of the data being analyzed to ensure that the insights derived are both relevant and actionable."}),"\n",(0,n.jsx)(s.h2,{id:"cheatsheet",children:"Cheatsheet"}),"\n",(0,n.jsx)(s.p,{children:"These are high-level definitions of major terms you will need to know."}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"AnalyticsSeries"})," - The individual metric values, comprised of ",(0,n.jsx)(s.code,{children:"(value, start, end)"}),". There should be one of these for every change in value."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"AnalyticsDimension"})," - Shared objects that decorate series objects with ",(0,n.jsx)(s.code,{children:"name"})," and ",(0,n.jsx)(s.code,{children:"path"})," information. Used to relate metrics to one another."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Path"})," - Composable, ",(0,n.jsx)(s.code,{children:"/"}),"-delimited string field on dimension that is used to ",(0,n.jsx)(s.em,{children:"determine specificity"})," during queries."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"LOD"})," - A number that, when paired with ",(0,n.jsx)(s.code,{children:"path"}),", determines how to aggregate values across dimensions."]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Granularity"}),' - Determines how to aggregate values over time, like "monthly" or "yearly".']}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,n.jsx)(s.p,{children:"Next steps depend on use case."}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["For developers looking to ",(0,n.jsx)(s.strong,{children:"input data"}),", or ",(0,n.jsx)(s.strong,{children:"query data with Typescript"}),", see the ",(0,n.jsx)(s.a,{href:"./typescript/",children:"Typescript"})," docs."]}),"\n",(0,n.jsxs)(s.li,{children:["For developers interested in ",(0,n.jsx)(s.strong,{children:"querying data with GraphQL"}),", see the ",(0,n.jsx)(s.a,{href:"./graphql/",children:"GraphQL"})," documentation. Data cannot be input through GraphQL."]}),"\n",(0,n.jsxs)(s.li,{children:["For developers interested in ",(0,n.jsx)(s.strong,{children:"contributing to this project"}),", see the developer documentation ",(0,n.jsx)(s.a,{href:"https://github.com/powerhouse-inc/analytics-engine",children:"on GitHub"}),"."]}),"\n"]})]})}function c(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},5914:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/lod-4ca833cfdcd8e2b794ba0bd38332d452.jpg"},5983:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/overview-6-edad3f6472c2c23e243c2691d2f41b7d.jpg"},6227:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/overview-5-f51bbc343a8b0b40908bf3e2559b1703.jpg"},6569:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/paths-1-cbadeb7ae29992aff6baf1bdbc0f902f.jpg"},7474:(e,s,t)=>{t.d(s,{R:()=>r,x:()=>o});var i=t(2155);const n={},a=i.createContext(n);function r(e){const s=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(a.Provider,{value:s},e.children)}},7700:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/overview-1-89410d440b2dfe776d26923a6182eb7d.jpg"},8734:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/high-level-7193b15619c2a871c21aef9b8e8c3846.jpg"},9792:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/overview-2-5cc54fc539e6581971f1e57a9295e08c.jpg"}}]);