"use strict";(self.webpackChunk_powerhousedao_academy=self.webpackChunk_powerhousedao_academy||[]).push([[3231],{6280:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"academy/ComponentLibrary/CreateCustomScalars","title":"Step 1: Create Custom Scalars","description":"This tutorial provides step-by-step instructions for creating custom scalars & components, and to contributing to the document-engineering project.","source":"@site/docs/academy/06-ComponentLibrary/02-CreateCustomScalars.md","sourceDirName":"academy/06-ComponentLibrary","slug":"/academy/ComponentLibrary/CreateCustomScalars","permalink":"/academy/ComponentLibrary/CreateCustomScalars","draft":false,"unlisted":false,"editUrl":"https://github.com/powerhouse-inc/powerhouse-docs/tree/dev/docs/academy/06-ComponentLibrary/02-CreateCustomScalars.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"academySidebar","previous":{"title":"Document-Engineering","permalink":"/academy/ComponentLibrary/DocumentEngineering"},"next":{"title":"Step 2: Integrate Your Scalar into a React Component","permalink":"/academy/ComponentLibrary/IntegrateIntoAReactComponent"}}');var t=r(5723),a=r(7474);const i={},o="Step 1: Create Custom Scalars",l={},c=[{value:"Creating New GraphQL Scalars",id:"creating-new-graphql-scalars",level:3},{value:"Step 1: Create the Scalar File",id:"step-1-create-the-scalar-file",level:2},{value:"Key Components to Update:",id:"key-components-to-update",level:3},{value:"Step 2: Register the Scalar in <code>scalars.ts</code>",id:"step-2-register-the-scalar-in-scalarsts",level:2},{value:"2.1 Add Namespace Import",id:"21-add-namespace-import",level:3},{value:"2.2 Add Type Export",id:"22-add-type-export",level:3},{value:"2.3 Add to Export Object",id:"23-add-to-export-object",level:3},{value:"2.4 Add to Custom Scalars",id:"24-add-to-custom-scalars",level:3},{value:"2.5 Add to Resolvers",id:"25-add-to-resolvers",level:4},{value:"2.6 Add to Type Definitions",id:"26-add-to-type-definitions",level:3},{value:"2.7 Add to Generator Type Definitions",id:"27-add-to-generator-type-definitions",level:3},{value:"2.8 Add to Validation Schema",id:"28-add-to-validation-schema",level:3},{value:"Step 3: Create Tests for Your Scalar",id:"step-3-create-tests-for-your-scalar",level:2},{value:"Required Test Cases",id:"required-test-cases",level:4},{value:"Serialization Tests",id:"serialization-tests",level:5},{value:"Parse Value Tests",id:"parse-value-tests",level:5},{value:"Parse Literal Tests",id:"parse-literal-tests",level:5},{value:"Testing Best Practices",id:"testing-best-practices",level:4},{value:"Example Edge Cases for Different Scalar Types",id:"example-edge-cases-for-different-scalar-types",level:4},{value:"Step 4: Validate Your Implementation",id:"step-4-validate-your-implementation",level:2},{value:"Common Scalar Types",id:"common-scalar-types",level:3},{value:"String-based Scalars",id:"string-based-scalars",level:4},{value:"Number-based Scalars",id:"number-based-scalars",level:4},{value:"Date-based Scalars",id:"date-based-scalars",level:4},{value:"Tips",id:"tips",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"step-1-create-custom-scalars",children:"Step 1: Create Custom Scalars"})}),"\n",(0,t.jsxs)(n.p,{children:["This tutorial provides step-by-step instructions for creating custom scalars & components, and to contributing to the document-engineering project.\nThe github repo for the Document-Engineering can be found ",(0,t.jsx)(n.a,{href:"https://github.com/powerhouse-inc/document-engineering/tree/main",children:"here"})]}),"\n",(0,t.jsx)(n.h3,{id:"creating-new-graphql-scalars",children:"Creating New GraphQL Scalars"}),"\n",(0,t.jsxs)(n.p,{children:["GraphQL scalars are custom data types that define how data is validated, serialized, and parsed. This guide will walk you through creating a new scalar in the ",(0,t.jsx)(n.code,{children:"src/scalars/graphql/"})," directory."]}),"\n",(0,t.jsx)(n.h2,{id:"step-1-create-the-scalar-file",children:"Step 1: Create the Scalar File"}),"\n",(0,t.jsxs)(n.p,{children:["Create a new TypeScript file in ",(0,t.jsx)(n.code,{children:"src/scalars/graphql/"})," for your scalar. Use ",(0,t.jsx)(n.code,{children:"EmailAddress.ts"})," as a reference."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Example: Creating a ",(0,t.jsx)(n.code,{children:"PhoneNumber.ts"})," scalar"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import {\n  GraphQLError,\n  GraphQLScalarType,\n  type GraphQLScalarTypeConfig,\n  Kind,\n} from "graphql";\nimport { z } from "zod";\n\nexport interface ScalarType {\n  input: string;\n  output: string;\n}\n\nexport const type = "string"; // TS type in string form\n\nexport const typedef = "scalar PhoneNumber";\n\nexport const schema = z\n  .string()\n  .regex(/^\\+?[1-9]\\d{1,14}$/, "Invalid phone number format");\n\nexport const stringSchema =\n  \'z.string().regex(/^\\\\+?[1-9]\\\\d{1,14}$/, "Invalid phone number format")\';\n\nconst phoneValidation = (value: unknown): string => {\n  if (typeof value !== "string") {\n    throw new GraphQLError(`Value is not string: ${JSON.stringify(value)}`);\n  }\n\n  const result = schema.safeParse(value);\n\n  if (result.success) return result.data;\n  throw new GraphQLError(result.error.message);\n};\n\nexport const config: GraphQLScalarTypeConfig<string, string> = {\n  name: "PhoneNumber",\n  description:\n    "A field whose value conforms to international phone number format.",\n  serialize: phoneValidation,\n  parseValue: phoneValidation,\n  parseLiteral: (value) => {\n    if (value.kind !== Kind.STRING) {\n      throw new GraphQLError(\n        `Can only validate strings as phone numbers but got a: ${value.kind}`,\n        { nodes: value },\n      );\n    }\n\n    return phoneValidation(value.value);\n  },\n};\n\nexport const scalar = new GraphQLScalarType(config);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"key-components-to-update",children:"Key Components to Update:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"type"})}),": The TypeScript type (usually ",(0,t.jsx)(n.code,{children:"'string'"})," for text-based scalars)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"typedef"})}),": The GraphQL type definition (e.g., ",(0,t.jsx)(n.code,{children:"'scalar PhoneNumber'"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"schema"})}),": Zod validation schema for your data type"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"stringSchema"})}),": String representation of the zod schema (used for code generation)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation function"}),": Custom validation logic for your scalar"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"config.name"})}),": The name of your scalar (must match the typedef)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"config.description"})}),": Human-readable description of the scalar"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"step-2-register-the-scalar-in-scalarsts",children:["Step 2: Register the Scalar in ",(0,t.jsx)(n.code,{children:"scalars.ts"})]}),"\n",(0,t.jsxs)(n.p,{children:["After creating your scalar file, you need to register it in ",(0,t.jsx)(n.code,{children:"src/scalars/graphql/scalars.ts"}),". This involves updating multiple sections of the file.\nThe github repo for the Document-Engineering can be found ",(0,t.jsx)(n.a,{href:"https://github.com/powerhouse-inc/document-engineering/tree/main",children:"here"})]}),"\n",(0,t.jsx)(n.h3,{id:"21-add-namespace-import",children:"2.1 Add Namespace Import"}),"\n",(0,t.jsx)(n.p,{children:"Add your scalar to the namespace imports section (around line 2):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// namespace imports -- DO NOT REMOVE OR EDIT THIS COMMENT\nimport * as Amount from "./Amount.js";\nimport * as AmountCrypto from "./AmountCrypto.js";\n// ... other imports ...\nimport * as PhoneNumber from "./PhoneNumber.js"; // ADD THIS LINE\nimport * as URLScalar from "./URL.js";\n'})}),"\n",(0,t.jsx)(n.h3,{id:"22-add-type-export",children:"2.2 Add Type Export"}),"\n",(0,t.jsx)(n.p,{children:"Add the type export (around line 22):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// export types -- DO NOT REMOVE OR EDIT THIS COMMENT\nexport type { ScalarType as AmountScalarType } from "./Amount.js";\n// ... other type exports ...\nexport type { ScalarType as PhoneNumberScalarType } from "./PhoneNumber.js"; // ADD THIS LINE\nexport type { ScalarType as URLScalarType } from "./URL.js";\n'})}),"\n",(0,t.jsx)(n.h3,{id:"23-add-to-export-object",children:"2.3 Add to Export Object"}),"\n",(0,t.jsx)(n.p,{children:"Add your scalar to the main export object (around line 40):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export {\n  Amount,\n  AmountCrypto,\n  // ... other exports ...\n  PhoneNumber, // ADD THIS LINE\n  URLScalar,\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"24-add-to-custom-scalars",children:"2.4 Add to Custom Scalars"}),"\n",(0,t.jsxs)(n.p,{children:["Add your scalar to the ",(0,t.jsx)(n.code,{children:"customScalars"})," object (around line 54):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const customScalars: Record<string, BasePHScalar<any>> = {\n  // ... other scalars ...\n  PhoneNumber, // ADD THIS LINE\n  URLScalar,\n} as const;\n"})}),"\n",(0,t.jsx)(n.h4,{id:"25-add-to-resolvers",children:"2.5 Add to Resolvers"}),"\n",(0,t.jsxs)(n.p,{children:["Add your scalar to the ",(0,t.jsx)(n.code,{children:"resolvers"})," object (around line 74):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const resolvers = {\n  // export resolvers -- DO NOT REMOVE OR EDIT THIS COMMENT\n  AmountTokens: AmountTokens.scalar,\n  // ... other resolvers ...\n  PhoneNumber: PhoneNumber.scalar, // ADD THIS LINE\n  Amount: Amount.scalar,\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"26-add-to-type-definitions",children:"2.6 Add to Type Definitions"}),"\n",(0,t.jsxs)(n.p,{children:["Add your typedef to the ",(0,t.jsx)(n.code,{children:"typeDefs"})," array (around line 90):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const typeDefs = [\n  // export typedefs -- DO NOT REMOVE OR EDIT THIS COMMENT\n  AmountTokens.typedef,\n  // ... other typedefs ...\n  PhoneNumber.typedef, // ADD THIS LINE\n  Amount.typedef,\n];\n"})}),"\n",(0,t.jsx)(n.h3,{id:"27-add-to-generator-type-definitions",children:"2.7 Add to Generator Type Definitions"}),"\n",(0,t.jsxs)(n.p,{children:["Add your scalar to the ",(0,t.jsx)(n.code,{children:"generatorTypeDefs"})," object (around line 105):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const generatorTypeDefs = {\n  // export generator typedefs -- DO NOT REMOVE OR EDIT THIS COMMENT\n  [AmountTokens.config.name]: AmountTokens.type,\n  // ... other entries ...\n  [PhoneNumber.config.name]: PhoneNumber.type, // ADD THIS LINE\n  [Amount.config.name]: Amount.type,\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"28-add-to-validation-schema",children:"2.8 Add to Validation Schema"}),"\n",(0,t.jsxs)(n.p,{children:["Add your scalar to the ",(0,t.jsx)(n.code,{children:"validationSchema"})," object (around line 120):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export const validationSchema = {\n  // export validation schema -- DO NOT REMOVE OR EDIT THIS COMMENT\n  [AmountTokens.config.name]: AmountTokens.stringSchema,\n  // ... other entries ...\n  [PhoneNumber.config.name]: PhoneNumber.stringSchema, // ADD THIS LINE\n  [Amount.config.name]: Amount.stringSchema,\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"step-3-create-tests-for-your-scalar",children:"Step 3: Create Tests for Your Scalar"}),"\n",(0,t.jsxs)(n.p,{children:["Every scalar must have comprehensive tests to ensure it works correctly. Create a test file in ",(0,t.jsx)(n.code,{children:"src/scalars/graphql/test/"})," following the naming convention ",(0,t.jsx)(n.code,{children:"YourScalar.test.ts"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Example: Creating ",(0,t.jsx)(n.code,{children:"PhoneNumber.test.ts"})]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Kind } from "graphql";\nimport { scalar } from "../PhoneNumber.js";\n\ndescribe("PhoneNumber Scalar", () => {\n  it("should serialize a phone number", () => {\n    const phoneNumber = "+1234567890";\n\n    expect(scalar.serialize(phoneNumber)).toBe(phoneNumber);\n  });\n\n  it("should throw an error if the value is not a string", () => {\n    const phoneNumber = 123;\n\n    expect(() => scalar.serialize(phoneNumber)).toThrow();\n  });\n\n  it("should throw an error if the value is not a valid phone number", () => {\n    const phoneNumber = "invalid-phone";\n\n    expect(() => scalar.serialize(phoneNumber)).toThrow();\n  });\n\n  it("should parse a valid phone number", () => {\n    const phoneNumber = "+1234567890";\n\n    expect(scalar.parseValue(phoneNumber)).toBe(phoneNumber);\n  });\n\n  it("should throw an error if parse a value that is not a valid phone number", () => {\n    const phoneNumber = "invalid-phone";\n\n    expect(() => scalar.parseValue(phoneNumber)).toThrow();\n  });\n\n  it("should throw an error if parse a value that is not a string", () => {\n    const phoneNumber = 123;\n\n    expect(() => scalar.parseValue(phoneNumber)).toThrow();\n  });\n\n  it("should parse a valid phone number from a literal", () => {\n    const phoneNumber = "+1234567890";\n\n    expect(\n      scalar.parseLiteral({\n        kind: Kind.STRING,\n        value: phoneNumber,\n      }),\n    ).toBe(phoneNumber);\n  });\n\n  it("should throw an error if parse a literal that is not a valid phone number", () => {\n    const phoneNumber = "invalid-phone";\n\n    expect(() =>\n      scalar.parseLiteral({\n        kind: Kind.STRING,\n        value: phoneNumber,\n      }),\n    ).toThrow();\n  });\n\n  it("should throw an error if parse a literal that is not a string", () => {\n    const phoneNumber = "+1234567890";\n\n    expect(() =>\n      scalar.parseLiteral({\n        kind: Kind.INT,\n        value: phoneNumber,\n      }),\n    ).toThrow();\n  });\n});\n'})}),"\n",(0,t.jsx)(n.h4,{id:"required-test-cases",children:"Required Test Cases"}),"\n",(0,t.jsx)(n.p,{children:"Your scalar tests should cover these essential scenarios:"}),"\n",(0,t.jsx)(n.h5,{id:"serialization-tests",children:"Serialization Tests"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Valid values"}),": Test that valid inputs are serialized correctly"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Invalid types"}),": Test that non-string inputs throw errors"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Invalid format"}),": Test that strings not matching your validation throw errors"]}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"parse-value-tests",children:"Parse Value Tests"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Valid values"}),": Test that valid inputs are parsed correctly"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Invalid format"}),": Test that invalid strings throw errors"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Invalid types"}),": Test that non-string inputs throw errors"]}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"parse-literal-tests",children:"Parse Literal Tests"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\u2705 ",(0,t.jsx)(n.strong,{children:"Valid STRING literals"}),": Test that valid string literals are parsed correctly"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Invalid STRING literals"}),": Test that invalid string literals throw errors"]}),"\n",(0,t.jsxs)(n.li,{children:["\u274c ",(0,t.jsx)(n.strong,{children:"Non-STRING literals"}),": Test that non-string literal kinds (INT, FLOAT, etc.) throw errors"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"testing-best-practices",children:"Testing Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test edge cases"}),": Include boundary values and common invalid inputs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test multiple valid formats"}),": If your scalar accepts different valid formats, test them all"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use descriptive test names"}),": Make it clear what each test is validating"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Follow the naming convention"}),": ",(0,t.jsx)(n.code,{children:"YourScalar.test.ts"})," in the ",(0,t.jsx)(n.code,{children:"test/"})," directory"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-edge-cases-for-different-scalar-types",children:"Example Edge Cases for Different Scalar Types"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"String-based scalars (like PhoneNumber):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Test empty string\nexpect(() => scalar.parseValue("")).toThrow();\n\n// Test too long/short values\nexpect(() => scalar.parseValue("123")).toThrow();\nexpect(() => scalar.parseValue("+" + "1".repeat(20))).toThrow();\n\n// Test special characters\nexpect(() => scalar.parseValue("+1-234-567-890")).not.toThrow();\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Number-based scalars:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Test zero\nexpect(scalar.parseValue(0)).toBe(0);\n\n// Test negative numbers\nexpect(() => scalar.parseValue(-1)).toThrow();\n\n// Test decimal numbers\nexpect(scalar.parseValue(123.45)).toBe(123.45);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Date-based scalars:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Test valid ISO date\nexpect(scalar.parseValue("2023-12-25T00:00:00Z")).toBe("2023-12-25T00:00:00Z");\n\n// Test invalid date format\nexpect(() => scalar.parseValue("25/12/2023")).toThrow();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"step-4-validate-your-implementation",children:"Step 4: Validate Your Implementation"}),"\n",(0,t.jsx)(n.p,{children:"After implementing your scalar and tests, make sure to:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Run the tests"})," to ensure they all pass"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build the project"})," to ensure there are no TypeScript errors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test GraphQL queries"})," that use your new scalar"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Verify code generation"})," works with your new scalar"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"common-scalar-types",children:"Common Scalar Types"}),"\n",(0,t.jsx)(n.p,{children:"Here are some common patterns for different types of scalars:"}),"\n",(0,t.jsx)(n.h4,{id:"string-based-scalars",children:"String-based Scalars"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export const type = "string";\nexport const schema = z.string().min(1).max(100);\n'})}),"\n",(0,t.jsx)(n.h4,{id:"number-based-scalars",children:"Number-based Scalars"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export const type = "number";\nexport const schema = z.number().positive();\n'})}),"\n",(0,t.jsx)(n.h4,{id:"date-based-scalars",children:"Date-based Scalars"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export const type = "string";\nexport const schema = z.string().datetime();\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Contributing and UI for Scalars"})}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Open Source"}),": Please submit contributions as a pull request to the Powerhouse team."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"UI is Optional but Helpful"}),": A design or UI for your scalar isn't required, but it helps reviewers understand its purpose."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Semantic Scalars"}),": Some scalars don't need a unique UI. For instance, ",(0,t.jsx)(n.code,{children:"Title"})," and ",(0,t.jsx)(n.code,{children:"Description"})," might both use a simple text input but serve a semantic role by adding specific meaning and validation to the schema."]}),"\n"]})]}),"\n",(0,t.jsx)(n.h3,{id:"tips",children:"Tips"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Always follow the naming convention: use PascalCase for scalar names"}),"\n",(0,t.jsx)(n.li,{children:"Include meaningful validation in your Zod schema"}),"\n",(0,t.jsx)(n.li,{children:"Write clear, descriptive error messages"}),"\n",(0,t.jsxs)(n.li,{children:["Keep the ",(0,t.jsx)(n.code,{children:"stringSchema"})," in sync with your ",(0,t.jsx)(n.code,{children:"schema"})," definition"]}),"\n",(0,t.jsx)(n.li,{children:"Test edge cases in your validation function"}),"\n",(0,t.jsxs)(n.li,{children:["Update all required sections in ",(0,t.jsx)(n.code,{children:"scalars.ts"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},7474:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var s=r(2155);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);