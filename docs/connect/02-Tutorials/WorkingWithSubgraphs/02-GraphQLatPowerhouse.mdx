# GraphQL at Powerhouse

GraphQL plays a fundamental role in defining document model data schemas, handling data access patterns, and enabling event-driven workflows within the Powerhouse ecosystem. This document provides an intro to graphQL and how it is used at Powerhouse.

More specifically, GraphQL is used as:
- The **schema definition language (SDL)** for defining our document models and thereby self-documenting the API to the data model. It allows developers to define the structure and relationships of data in a strongly-typed format.
- As the **query language in subgraphs**, which allow different services to expose and query structured data dynamically.


## Powerhouse's use of GraphQL Subgraphs
Powerhouse structures its data into subgraphs, which are modular GraphQL services that connect to the Reactor, Powerhouse's core data infrastructure, or Operational Data Stores fueled by data from a processor.

### Fetching data from the Reactor

Powerhouse uses GraphQL to expose system-level data, such as drives, users, and operational records.  
Example: The **System Subgraph** allows querying of drives, stored files and folders.

### Operational Data Stores

Custom subgraphs can be created to store and retrieve operational data in real time.
Example: A subgraph can track file uploads and expose this data via GraphQL queries.    ????

??

```graphql
type File {
  id: ID!
  name: String!
  size: Int!
  createdAt: DateTime!
}

type Query {
  getFile(id: ID!): File
}
```
This schema ensures that every File entity has an ID, name, size, and timestamp.

??

In Powerhouse, each subgraph has its own SDL, ensuring modularity and flexibility while working within the ecosystem.

Powerhouse uses CQRS to separate write operations (commands) from read operations (queries).   
This improves system scalability and flexibility. 
- GraphQL Queries handle read operations, retrieving structured data efficiently. 
- GraphQL Mutations handle write operations, modifying the state in a controlled manner.

Powerhouse's subgraphs act as the read layer, while processors handle write operations into operational data stores.  
This prevents conflicts between querying and modifying data.

#### Example: Read & Write Separation  
**Read Model (Query)**  
Fetching file metadata:

```graphql
query {
  getFile(id: "123") {
    name
    size
  }
}
```

**Write Model (Mutation)**    
Uploading a new file:

```graphql
mutation {
  createFile(name: "document.pdf", size: 1024) {
    id
    name
  }
}
```

### Powerhouse-Specific CQRS Breakdown

| Layer | Role | GraphQL Usage | Implementation |
| --- | --- | --- | --- |
| Write Model (Commands) | Handles state changes (adding, modifying, deleting) | GraphQL Mutations | Processor |
| Read Model (Queries) | Optimized for fetching/reading/retrieving data | GraphQL Queries | Subgraph |


### GraphQL & Event-Driven Architecture (EDA)
Event-Driven Architecture (EDA) enables asynchronous processing where events trigger actions. Powerhouse uses GraphQL to expose real-time event data from its Reactor and Operational Data Stores.

How GraphQL Fits into EDA
- **Real-Time Data Exposure** – Subgraphs fetch event-based data updates.
- **Event Subscription Mechanism** – Powerhouse is working towards integrating GraphQL Subscriptions for real-time updates.
- **Efficient Decoupling** – Events are stored in an operational datastore, and GraphQL queries retrieve structured results.

#### Example: Powerhouse's Event Flow
1. Processor detects an event (e.g., file upload).
2. Writes event data to the Operational Data Store.
3. Subgraph exposes the updated data via GraphQL.

### Future Powerhouse Enhancement: GraphQL Subscriptions
Although Powerhouse currently uses queries and mutations, GraphQL Subscriptions could allow real-time streaming of event-based data.

#### Example (future implementation):

```graphql 
subscription {
  fileUploaded {
    id
    name
  }
}
```
This would enable clients to listen for new file uploads without polling.

### 4. Read and Write Models in Powerhouse's Architecture  
Powerhouse's architecture follows CQRS principles, dividing the system into two models:



### Read Model (Query Side)
- Optimized for data retrieval
- Structured using GraphQL Queries
- Aggregates and exposes data via a subgraph
- Pulls data from Operational Data Stores, Analytics Stores, and Reactor
- Subgraphs do not directly modify the data—they only expose pre-processed information

**Example: Querying Read Model**  
This retrieves structured data without modifying the state.
```graphql
query {
  getFile(id: "123") {
    name
    size
  }
}
```







