# Job Ordering and Dependency System

## Overview

The queue system will transition from using a single `documentId` for job ordering to a more flexible `queueHint` array that enables graph-like dependency structures. This allows for more sophisticated job scheduling.

## Core Concepts

### QueueHint Structure

The `queueHint` is an array of strings that defines a job's position in the dependency graph:

```typescript
interface Job {
  id: string;
  queueHint: string[];  // Ordered array of dependency identifiers
  // ... other fields
}
```

### Dependency Resolution

Jobs are organized based on their `queueHint` values, creating a hierarchical dependency structure:

1. **Level 0 (Root)**: Empty hint `[]` - jobs with no dependencies
2. **Level 1**: Single hint `["A"]` - jobs depending on root level A
3. **Level 2**: Two hints `["A", "B"]` - jobs depending on path A→B
4. **Level N**: N hints - jobs with N levels of dependencies

## Ordering Rules

### 1. Serial Execution Within Same Path

Jobs sharing the same complete queueHint path execute serially:

```
Job1 = ["doc1", "scope1", "branch1"]
Job2 = ["doc1", "scope1", "branch1"]  
→ Job2 waits for Job1 to complete
```

### 2. Parallel Execution for Different Paths

Jobs with different queueHint paths can execute in parallel:

```
Job1 = ["doc1", "scope1"]
Job2 = ["doc2", "scope1"]
→ Can execute simultaneously
```

### 3. Parent-Child Dependencies

Jobs with longer hints depend on jobs with matching prefixes:

```
Job1: queueHint = ["doc1"]
Job2: queueHint = ["doc1", "operation1"]
→ Job2 depends on Job1 (prefix match)
```

### 4. Sibling Independence

Jobs at the same level with different immediate parents are independent:

```
Job1: queueHint = ["doc1", "op1"]
Job2: queueHint = ["doc1", "op2"]
→ Can execute in parallel (different immediate parent)
```

## Queue Key Generation

The queue key is generated by joining all queueHint elements:

```typescript
function createQueueKey(queueHint: string[]): string {
  return queueHint.join(':') || 'root';
}
```

Examples:
- `[]` → `"root"`
- `["doc1"]` → `"doc1"`
- `["doc1", "scope1", "branch1"]` → `"doc1:scope1:branch1"`

## Execution Tracking

### Active Execution Registry

Track executing jobs by their full path and all parent paths:

```typescript
activeExecutions: Map<string, Set<string>> = new Map();

// When job starts:
// queueHint = ["A", "B", "C"]
// Register as executing at:
// - "A" (blocks new jobs at ["A"])
// - "A:B" (blocks new jobs at ["A", "B"])  
// - "A:B:C" (blocks new jobs at ["A", "B", "C"])
```

### Dequeue Logic

A job can be dequeued only if:
1. No job is executing at its exact path
2. No job is executing at any parent path
3. No job is executing at any child path

## Examples

### Example 1: Document-Based Operations

```typescript
// Traditional document operations
Job1: { queueHint: ["doc1"], actions: [...] }
Job2: { queueHint: ["doc1"], actions: [...] }
Job3: { queueHint: ["doc2"], actions: [...] }

Execution order:
- Job1 starts (doc1 path)
- Job3 starts (doc2 path - parallel)
- Job2 waits for Job1 (same doc1 path)
- Job1 completes → Job2 starts
```

### Example 2: Hierarchical Dependencies

```typescript
// Parent job
Job1: { queueHint: ["import-123"], actions: [...] }

// Child jobs (depend on parent)
Job2: { queueHint: ["import-123", "record-1"], actions: [...] }
Job3: { queueHint: ["import-123", "record-2"], actions: [...] }
Job4: { queueHint: ["import-123", "record-3"], actions: [...] }

// Grandchild job
Job5: { queueHint: ["import-123", "record-1", "validate"], actions: [...] }

Execution flow:
1. Job1 starts (parent validation)
2. Job1 completes
3. Job2, Job3, Job4 start in parallel (different record paths)
4. When Job2 completes → Job5 can start
```

### Example 3: Complex Document Workflow

```typescript
// Document collaboration workflow
Job1: { queueHint: ["doc-123"], actions: [{ type: "INIT_COLLABORATION" }] }
Job2: { queueHint: ["doc-123", "review"], actions: [{ type: "START_REVIEW_PROCESS" }] }
Job3: { queueHint: ["doc-123", "review", "reviewer-A"], actions: [{ type: "ASSIGN_REVIEWER", payload: { reviewerId: "A" } }] }
Job4: { queueHint: ["doc-123", "review", "reviewer-B"], actions: [{ type: "ASSIGN_REVIEWER", payload: { reviewerId: "B" } }] }
Job5: { queueHint: ["doc-123", "validation"], actions: [{ type: "VALIDATE_SCHEMA" }] }
Job6: { queueHint: ["doc-123", "publish"], actions: [{ type: "PREPARE_PUBLICATION" }] }

Execution flow:

1. Job1 executes (initialize collaboration session)
2. Job2 executes (set up review process)
3. Job3 and Job4 execute in parallel (assign different reviewers)
4. Job5 can execute after Job1 (sibling to review branch)
5. Job6 can execute independently of Job5 (different workflow branch)
```

## Implementation Considerations

### Queue Storage Structure

```typescript
interface QueueState {
  // Queues organized by full path
  queues: Map<string, Job[]>;
  
  // Job ID to queue key mapping
  jobIdToQueueKey: Map<string, string>;
  
  // Active executions by path prefix
  activeExecutions: Map<string, Set<string>>;
  
  // Job ID to full hint mapping (for cleanup)
  jobIdToHint: Map<string, string[]>;
}
```

### Dequeue Algorithm

```typescript
function canDequeue(job: Job, activeExecutions: Map<string, Set<string>>): boolean {
  const hint = job.queueHint;
  
  // Check if any parent path is executing
  for (let i = 0; i <= hint.length; i++) {
    const pathKey = hint.slice(0, i).join(':') || 'root';
    if (activeExecutions.has(pathKey)) {
      const executing = activeExecutions.get(pathKey);
      if (executing && executing.size > 0) {
        return false; // Parent or same path is executing
      }
    }
  }
  
  // Check if any child path is executing
  const fullPath = hint.join(':') || 'root';
  for (const [path, executing] of activeExecutions.entries()) {
    if (path.startsWith(fullPath + ':') && executing.size > 0) {
      return false; // Child path is executing
    }
  }
  
  return true;
}
```
