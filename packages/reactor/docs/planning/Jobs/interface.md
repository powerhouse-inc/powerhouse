# Interface

```tsx

/**
 * Job execution statuses
 */
export enum JobStatus {
  /** Job is queued but not yet started */
  PENDING = 'PENDING',
  /** Job is currently being executed */
  RUNNING = 'RUNNING',
  /** Job completed successfully */
  COMPLETED = 'COMPLETED',
  /** Job failed (may be retried) */
  FAILED = 'FAILED',
}

export type Job = {
  /** Unique job id, generated by the queue */
  id: string;

  /** The document id that the job is operating on */
  documentId: string;

  /** The scopes affected by the actions */
  scopes: string[];

  /** The branch that the job is operating on */
  branch: string;

  /** The list of actions to apply */
  actions: Action[];

  /** The optional expected hash of the resulting state */
  resultingHash?: string;

  /** Current status of the job */
  status: JobStatus;
};

export type JobExecutionConfig = {
  /** Maximum number of retries allowed */
  maxRetries?: number;
};

/**
 * Represents the result of a job execution
 */
export type JobResult = {
  /** The job that was executed */
  job: Job;
  
  /** Whether the job executed successfully */
  success: boolean;
  
  /** Timestamp when the job execution completed */
  completedAt: string;
  
  /** Duration of job execution in milliseconds */
  duration: number;

  /** The list of operations that were created, if successful, empty if not */
  operations: Operation[];
  
  /** Any additional metadata from the execution */
  metadata?: Record<string, any>;

  /** The error code if the job failed */
  errorCode?: number;
  
  /** Error message if the job failed */
  errorMessage?: string;
};

/**
 * Configuration options for the job executor
 */
export type JobExecutorManagerConfig = {
  /** Maximum number of concurrent jobs to execute */
  maxConcurrency?: number;
  
  /** Maximum time in milliseconds a job can run before being considered timed out */
  jobTimeout?: number;
  
  /** Base delay in milliseconds for exponential backoff retries */
  retryBaseDelay?: number;
  
  /** Maximum delay in milliseconds for exponential backoff retries */
  retryMaxDelay?: number;
};

export type JobExecutionConfig = {
  /** Maximum time in milliseconds a job can run before being considered timed out */
  jobTimeout?: number;
  
  /** Base delay in milliseconds for exponential backoff retries */
  retryBaseDelay?: number;
  
  /** Maximum delay in milliseconds for exponential backoff retries */
  retryMaxDelay?: number;
}

export interface IReducer {
  /**
   * Applies an action to a state and returns the new state.
   */
  apply(
    state: Draft<BaseStateFromDocument>,
    action: Action,
    dispatch: ActionDispatch,
  ): BaseStateFromDocument;
}

export interface IJobExecutor {
  /**
   * Executes a job.
   * 
   * @param job - The job to execute
   * @param config - Configuration options for the job execution
   * @param signal - Optional abort signal to cancel the promise. This does NOT cancel the job execution.
   * @returns Promise that resolves to the job result
   */
  execute(job: Job, config?: JobExecutionConfig, signal?: AbortSignal): Promise<JobResult>;
}

/**
 * Interface for executing jobs from the queue.
 */
export interface IJobExecutorManager {
  /**
   * Start the job executor.
   * 
   * Begins listening for 'jobAvailable' events from the event bus and executing jobs when capacity allows.
   * 
   * @param config - Configuration options for the executor
   * @param signal - Optional abort signal to cancel the request
   * 
   * @returns Promise that resolves when the executor is started
   */
  start(config?: JobExecutorManagerConfig, signal?: AbortSignal): Promise<void>;
  
  /**
   * Stop the job executor.
   * Gracefully stops listening for events and waits for current jobs to complete.
   * @param graceful - Whether to wait for current jobs to complete
   * @param signal - Optional abort signal to cancel the request
   * @returns Promise that resolves when the executor is stopped
   */
  stop(graceful?: boolean, signal?: AbortSignal): Promise<void>;
  
  /**
   * Get the current status of the job executor.
   * @param signal - Optional abort signal to cancel the request
   * @returns Promise that resolves to the executor status
   */
  getStatus(signal?: AbortSignal): Promise<{
    isRunning: boolean;
    activeJobs: number;
    totalJobsProcessed: number;
    totalJobsSucceeded: number;
    totalJobsFailed: number;
    lastJobCompletedAt?: string;
    uptime?: number;
  }>;
  
  /**
   * Get statistics about job execution performance.
   * @param signal - Optional abort signal to cancel the request
   * @returns Promise that resolves to execution statistics
   */
  getStats(signal?: AbortSignal): Promise<{
    averageExecutionTime: number;
    successRate: number;
    jobsPerSecond: number;
    queueBacklog: number;
  }>;
  
  /**
   * Pause job execution.
   * Stops processing new jobs but keeps the executor running.
   * @param signal - Optional abort signal to cancel the request
   * @returns Promise that resolves when execution is paused
   */
  pause(signal?: AbortSignal): Promise<void>;
  
  /**
   * Resume job execution.
   * Resumes processing jobs from the queue.
   * @param signal - Optional abort signal to cancel the request
   * @returns Promise that resolves when execution is resumed
   */
  resume(signal?: AbortSignal): Promise<void>;

  /**
   * Watch for a job to complete.
   * 
   * If the job is already completed, the promise will resolve immediately.
   * 
   * If the job does not exist, the promise will reject.
   * 
   * @param jobId - The id of the job to watch
   * @param signal - Optional abort signal to cancel the request
   * @returns Promise that resolves to the job result
   */
  watch(jobId: string, signal?: AbortSignal): Promise<JobResult>;
}

/**
 * Event types for the job executor
 */
export const JobExecutorEventTypes = {
  JOB_STARTED: 20000,
  JOB_COMPLETED: 20001,
  JOB_RETRY: 20003,
  JOB_FAILED: 20004,
  EXECUTOR_STARTED: 20005,
  EXECUTOR_STOPPED: 20006,
} as const;

/**
 * Error codes for job execution
 */
export const JobErrorCodes = {
  SIGNATURE_INVALID: 90001,
  UNAUTHORIZED: 90002,
  HASH_MISMATCH: 90003,
  REBASE_FAILED: 90004,
  LIBRARY_ERROR: 90005,
  IO_ERROR: 90006,
  GRACEFUL_ABORT: 90010,
} as const;

export class JobError extends Error {
  /**
   * The error code of the job error.
   */
  errorCode: number;

  /**
   * The error message of the job error.
   */
  errorMessage: string;

  constructor(errorCode: number, errorMessage: string) {
    super(errorMessage);

    this.errorCode = errorCode;
    this.errorMessage = errorMessage;
  }
}

export const JobEventTypes = {
  JOB_STARTED: 20000,
  JOB_COMPLETED: 20001,
  JOB_RETRY: 20003,
  JOB_FAILED: 20004,
} as const;

/** Event payload when a job begins execution */
export type JobStartedEvent = {
  job: Job;
  startedAt: string;
};

/** Event payload when a job completes successfully */
export type JobCompletedEvent = {
  job: Job;
  result: JobResult;
};

/** Event payload when a job is retried */
export type JobRetryEvent = {
  job: Job;
  error: JobError;
  retryCount: number;
};

/** Event payload when a job fails */
export type JobFailedEvent = {
  job: Job;
  error: JobError;
  willRetry: boolean;
  retryCount: number;
};

/** Event emitted when the executor starts */
export type ExecutorStartedEvent = {
  config: JobExecutorConfig;
  startedAt: string;
};

/** Event emitted when the executor stops */
export type ExecutorStoppedEvent = {
  stoppedAt: string;
  graceful: boolean;
};
```
