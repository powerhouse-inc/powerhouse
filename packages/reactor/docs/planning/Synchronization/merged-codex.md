# Synchronization – Codex Spec

This document defines the synchronization architecture using the *strand / thread / cable* vocabulary and describes how Reactor’s `IOperationIndex` collections power each component.

## Goals

- Provide a deterministic push/pull synchronization system that streams operations between reactors with bounded replay.
- Define the exact data structures, storage records, and transport semantics required to implement channels, schedulers, and health tracking.
- Optimize strand generation by leveraging `IOperationIndex` collections, removing per-document fan-out costs.

## Terminology

| Term | Meaning | Implementation Notes |
| --- | --- | --- |
| **Strand** | Ordered bundle of operations for a single synchronization unit (documentId + scope + branch). | Serialized as `StrandUpdate` payloads. Generated by slicing `IOperationIndex` results. |
| **Thread** | Set of strands tied to the same drive collection and remote. Drives cursor management. | Defined by `(remoteName, collectionId)` and persisted in `sync_remote_collections`. |
| **Cable** | Transport connection to a remote reactor (push or pull). | Implemented via `IChannel` with inbox/outbox/dead-letter mailboxes and ACK/NACK semantics. |

Collections act as multiplexers: every drive document defines a collection id via `driveCollectionId(branch, driveId)`. A thread maps directly to a collection cursor, so gathering all strands only requires scanning the index once per thread instead of per strand.

## Remote Filters and Collection Decomposition

1. **Input contract** – Remotes still provide `RemoteFilter` objects (document types, ids, scopes, branches).
2. **Decomposition** – `ISyncManager.add/setFilter` expands each filter into one or more `(collectionId, view)` pairs:
   - Use the canonical `driveCollectionId(branch, driveId)` helper for every drive id in the filter.
   - If a filter cannot yield at least one collection id (e.g., “watch non-drive doc X only”), throw immediately.
3. **Storage** – Each `(remoteName, collectionId)` pair becomes a thread row in `sync_remote_collections`, storing the last processed ordinal and the effective `ViewFilter`.
4. **Optimization** – When generating strands, the manager queries `IOperationIndex.find(collectionId, cursor, view, paging)` once per thread, then splits the results into strands for individual synchronization units.

## Data Structures

- **SynchronizationUnit** – `{ documentId, scope, branch, documentType, revision }`. Populated by replaying the `IOperationIndex` slice returned for a thread.
- **StrandUpdate** – Payload given to cables. Filled using the operations returned by the index and enriched with the latest revision/hash data from `IOperationStore.getRevisions`.
- **ThreadState** – Backed by `sync_remote_collections` rows plus an in-memory cache keyed by `(remoteName, collectionId)`.
- **JobHandle** – Extended structure from the new spec (fields: `id`, `remoteName`, `documentId`, `scopes`, `branch`, `operations`, `status`, `error`). Every strand that needs to be applied locally/remotely is wrapped in a `JobHandle`.
- **CableHealth** – `sync_remotes.status` record with `push` and `pull` sections. Updates happen after ACK/NACK handling (see below).

## Channels, Strands, and ACK Flow

1. **Producing strands**
   - Scheduler wakes up per thread, queries the index, and for each strand creates a `MutableJobHandle` (inbox side) or `JobHandle` (outbox side).
   - Handles carry `remoteName` so ACK/NACK routing and health updates are unambiguous.
2. **Cable lifecycle**
   - **Inbox:** Remote strand arrives → `MutableJobHandle.started()` → local job execution → on success send ACK (job id + remoteName) back through the cable; on failure send NACK with serialized `ChannelError`.
   - **Outbox:** Local strand ready for remote → `JobHandle` enqueued → awaiting ACK → upon ACK remove from outbox, advance thread cursor, update `sync_remote_collections` + `sync_remotes.status`. If NACK, move to `deadLetter` and apply retry/backoff (exponential with jitter as in new spec).
3. **Cable adapters**
   - Transport implementations (HTTP, WebSocket, in-memory) translate `StrandUpdate` payloads to and from the channel envelope while honoring ACK semantics.
   - Pull-based transports expose a `sync.strands`-style endpoint; once a response is processed successfully, the cable emits an ACK so cursors advance exactly once.

## Push Path

- Outbound remotes own cables whose `outbox` mailboxes are fed by the scheduler. The scheduler applies configurable debounce/coalescing logic when turning threads into strands and fetches operations via collection scans.
- ACKs from the remote commit cursor advancement: when a remote confirms receipt, the manager updates the thread cursor and any auxiliary per-listener revision (if maintained for API purposes) inside `sync_remote_collections`.

## Pull Path

- Inbound remotes own cables whose `inbox` mailboxes receive strands transported from the remote reactor.
- Pull transports read thread pages over their chosen protocol, wrap them in `MutableJobHandle`s, enqueue local execution, and emit ACKs once the job completes successfully so the remote can advance its cursor.
- Disabling a cable unsubscribes it from the scheduler, closes transport connections, and marks `channel_health.state = "idle"` for the affected remote/thread rows.

## Storage Recap

| Table | Purpose |
| --- | --- |
| `sync_remotes` | Remote registry (channel config, filter JSON, options, aggregate status, last error). |
| `sync_remote_collections` | Thread rows (remoteName, collectionId, cursorOrdinal, view, lastPulledAt). Drives strand pagination. |
| `sync_remote_health` | Optional denormalized table for telemetry dashboards (push vs pull stats). |

All cursors remain **exclusive** (ordinal of last processed item). ACK handlers perform `UPDATE sync_remote_collections SET cursor_ordinal = :newOrdinal` inside a transaction that also prunes outbox entries to keep state consistent.

## Health & Telemetry

- Emit `SyncEventTypes.STATUS_CHANGED` events on the Reactor event bus whenever a cable health record mutates. Payload must include `remoteName`, `collectionId`, `push`/`pull` state, and latest error.
- Health transitions happen in response to:
  1. Scheduler dispatch (state → `"running"`),
  2. ACK success (state → `"idle"`, `lastSuccess` set),
  3. NACK or channel failure (state → `"error"`, `failureCount` incremented).
- Dashboards can continue to render “INITIAL_SYNC”, “SYNCING”, etc., by inspecting the channel health plus per-thread cursor deltas.

## Implementation Notes

1. Stand up the scheduler with collection-backed threads before adding transports to ensure cursor math is correct.
2. Provide transport adapters (HTTP, WebSocket, in-process) that convert `StrandUpdate`s to their respective wire formats and feed ACK/NACK events back into the cables.
3. Instrument parity tests for strand counts, cursor advancement, and health transitions to validate the implementation against this spec.

This spec defines the required data contracts, flows, and storage records for a deterministic synchronization system built on strands, threads, cables, and collection-optimized indexing.
