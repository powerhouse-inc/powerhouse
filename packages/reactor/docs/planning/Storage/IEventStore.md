# IEventStore

### Summary

- Append-only access to events produced by processing operations.
- Events contain the resulting state after an operation is applied.
- Each event references the operation that produced it.
- Events are consumed by downstream aggregates to build read models.
- Provides temporal queries for event replay and projection building.
- All writes are atomic.

### Interface

```tsx
interface IEventStore {
  /**
   * Append events produced by operation processing
   * This is called after operations are successfully stored
   */
  append(
    events: Event[],
    signal?: AbortSignal,
  ): Promise<void>;
  
  /**
   * Get a specific event by id
   */
  get(
    eventId: string,
    signal?: AbortSignal,
  ): Promise<Event>;
  
  /**
   * Get all events for a specific document stream
   */
  getByDocument(
    documentId: string,
    scope: string,
    branch: string,
    signal?: AbortSignal,
  ): Promise<Event[]>;
  
  /**
   * Get events since a specific index for a document stream
   */
  getSince(
    documentId: string,
    scope: string,
    branch: string,
    index: number,
    signal?: AbortSignal,
  ): Promise<Event[]>;
  
  /**
   * Get events since a specific timestamp
   */
  getSinceTimestamp(
    timestampUtcMs: number,
    signal?: AbortSignal,
  ): Promise<Event[]>;
  
  /**
   * Get events by operation id
   */
  getByOperationId(
    operationId: string,
    signal?: AbortSignal,
  ): Promise<Event[]>;
}

/**
 * Event type that contains the resulting state from processing an operation
 */
type Event = {
  /** Unique event id */
  id: string;
  
  /** The operation id that produced this event */
  operationId: string;
  
  /** Document this event applies to */
  documentId: string;
  
  /** Scope of the document */
  scope: string;
  
  /** Branch of the document */
  branch: string;
  
  /** Position in the event stream */
  index: number;
  
  /** Timestamp when the event was created */
  timestampUtcMs: number;
  
  /** The resulting state after applying the operation */
  state: unknown;
  
  /** Hash of the resulting state */
  stateHash: string;
  
  /** Optional metadata about the event */
  metadata?: {
    /** The type of state change */
    changeType?: 'create' | 'update' | 'delete';
    
    /** Any additional context */
    [key: string]: unknown;
  };
};
```

### Usage

```tsx
// After processing an operation
const events = await processOperation(operation);
await eventStore.append(events);

// Building a projection
const events = await eventStore.getByDocument(documentId, scope, branch);
const projection = events.reduce((state, event) => {
  return event.state;
}, initialState);

// Replaying events from a point in time
const recentEvents = await eventStore.getSinceTimestamp(lastCheckpoint);
for (const event of recentEvents) {
  await updateReadModel(event);
}
```

### Schema

The database schema, in prisma format:

```prisma
model Event {
  // Primary key
  id              String       @id @default(uuid())
  
  // Reference to the operation that produced this event
  operationId     String
  
  // Stream identification
  documentId      String
  scope           String
  branch          String
  
  // Ordering within the stream
  index           Int
  
  // Timestamps
  timestampUtcMs  DateTime
  createdAt       DateTime     @default(now())
  
  // State data
  state           Json
  stateHash       String
  
  // Optional metadata
  metadata        Json?
  
  // Compound unique constraint: one event per operation
  @@unique([operationId])
  
  // Compound unique constraint: unique index per stream
  @@unique([documentId, scope, branch, index], name: "unique_stream_index")
  
  // Indexes for efficient queries
  @@index([documentId, scope, branch, index DESC], name: "streamEvents")
  @@index([timestampUtcMs DESC], name: "temporalEvents")
  @@index([operationId], name: "operationEvents")
}
```

#### Indexes

- `streamEvents`: Allows efficient retrieval of events for a specific document stream in order
- `temporalEvents`: Enables time-based queries for building projections and snapshots
- `operationEvents`: Quick lookup of events by the operation that produced them

### Relationship to IOperationStore

The `IEventStore` works in tandem with the `IOperationStore`:

1. Operations (commands) are stored in `IOperationStore` without state
2. When operations are processed, events are generated and stored in `IEventStore`
3. The `operationId` field links events back to their originating commands
4. This separation allows for:
   - Command replay without storing redundant state
   - Independent scaling of command and event storage
   - Flexible event sourcing patterns

### Event Generation

Events are generated by the `IJobExecutor` after successfully processing operations:

```tsx
// In IJobExecutor
const operation = await queue.dequeue();
const currentState = await documentView.get(operation.documentId, operation.scope, operation.branch);
const newState = reducer(currentState, operation.action);

// Store the operation (command) without state
await operationStore.apply(operation);

// Generate and store the event with state
const event: Event = {
  id: generateId(),
  operationId: operation.id,
  documentId: operation.documentId,
  scope: operation.scope,
  branch: operation.branch,
  index: operation.index,
  timestampUtcMs: Date.now(),
  state: newState,
  stateHash: hash(newState),
};

await eventStore.append([event]);

// Emit to event bus for real-time subscribers
await eventBus.emit('document.changed', event);
```

### Notes

- Events are immutable once created
- The `state` field contains the complete document state after the operation
- For large documents, consider implementing snapshot strategies
- Events can be used to build multiple projections from the same source data
- The event store enables CQRS patterns with separate read models